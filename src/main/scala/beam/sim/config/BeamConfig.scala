// generated by tscfg 0.8.1 on Wed Aug 08 19:05:10 PDT 2018
// source: src/main/resources/beam-template.conf

package beam.sim.config

case class BeamConfig(
  beam: BeamConfig.Beam,
  matsim: BeamConfig.Matsim
)

object BeamConfig {
  case class Beam(
    agentsim: BeamConfig.Beam.Agentsim,
    calibration: BeamConfig.Beam.Calibration,
    debug: BeamConfig.Beam.Debug,
    inputDirectory: java.lang.String,
    metrics: BeamConfig.Beam.Metrics,
    outputs: BeamConfig.Beam.Outputs,
    physsim: BeamConfig.Beam.Physsim,
    routing: BeamConfig.Beam.Routing,
    spatial: BeamConfig.Beam.Spatial,
    warmStart: BeamConfig.Beam.WarmStart
  )

  object Beam {
    case class Agentsim(
      agents: BeamConfig.Beam.Agentsim.Agents,
      numAgents: scala.Int,
      simulationName: java.lang.String,
      taz: BeamConfig.Beam.Agentsim.Taz,
      thresholdForWalkingInMeters: scala.Int,
      timeBinSize: scala.Int,
      toll: BeamConfig.Beam.Agentsim.Toll,
      tuning: BeamConfig.Beam.Agentsim.Tuning
    )

    object Agentsim {
      case class Agents(
        drivingCost: BeamConfig.Beam.Agentsim.Agents.DrivingCost,
        modalBehaviors: BeamConfig.Beam.Agentsim.Agents.ModalBehaviors,
        rideHail: BeamConfig.Beam.Agentsim.Agents.RideHail
      )

      object Agents {
        case class DrivingCost(
          defaultLitersPerMeter: scala.Double,
          defaultPricePerGallon: scala.Double
        )

        object DrivingCost {

          def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Agents.DrivingCost = {
            BeamConfig.Beam.Agentsim.Agents.DrivingCost(
              defaultLitersPerMeter =
                if (c.hasPathOrNull("defaultLitersPerMeter")) c.getDouble("defaultLitersPerMeter")
                else 0.0001069,
              defaultPricePerGallon =
                if (c.hasPathOrNull("defaultPricePerGallon")) c.getDouble("defaultPricePerGallon")
                else 3.115
            )
          }
        }

        case class ModalBehaviors(
          defaultValueOfTime: scala.Double,
          lccm: BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.Lccm,
          modeChoiceClass: java.lang.String,
          mulitnomialLogit: BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit
        )

        object ModalBehaviors {
          case class Lccm(
            paramFile: java.lang.String
          )

          object Lccm {

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.Lccm = {
              BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.Lccm(
                paramFile =
                  if (c.hasPathOrNull("paramFile")) c.getString("paramFile")
                  else "/test/input/beamville/lccm-long.csv"
              )
            }
          }

          case class MulitnomialLogit(
            params: BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit.Params
          )

          object MulitnomialLogit {
            case class Params(
              bike_intercept: scala.Double,
              car_intercept: scala.Double,
              cost: scala.Double,
              drive_transit_intercept: scala.Double,
              ride_hail_intercept: scala.Double,
              ride_hail_transit_intercept: scala.Double,
              time: scala.Double,
              transfer: scala.Double,
              walk_intercept: scala.Double,
              walk_transit_intercept: scala.Double
            )

            object Params {

              def apply(
                c: com.typesafe.config.Config
              ): BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit.Params = {
                BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit.Params(
                  bike_intercept =
                    if (c.hasPathOrNull("bike_intercept")) c.getDouble("bike_intercept") else 0.0,
                  car_intercept =
                    if (c.hasPathOrNull("car_intercept")) c.getDouble("car_intercept") else 0.0,
                  cost = if (c.hasPathOrNull("cost")) c.getDouble("cost") else -1.0,
                  drive_transit_intercept =
                    if (c.hasPathOrNull("drive_transit_intercept"))
                      c.getDouble("drive_transit_intercept")
                    else 0.0,
                  ride_hail_intercept =
                    if (c.hasPathOrNull("ride_hail_intercept")) c.getDouble("ride_hail_intercept")
                    else -2.0,
                  ride_hail_transit_intercept =
                    if (c.hasPathOrNull("ride_hail_transit_intercept"))
                      c.getDouble("ride_hail_transit_intercept")
                    else 0.0,
                  time = if (c.hasPathOrNull("time")) c.getDouble("time") else -0.0047,
                  transfer = if (c.hasPathOrNull("transfer")) c.getDouble("transfer") else -1.4,
                  walk_intercept =
                    if (c.hasPathOrNull("walk_intercept")) c.getDouble("walk_intercept") else 0.0,
                  walk_transit_intercept =
                    if (c.hasPathOrNull("walk_transit_intercept"))
                      c.getDouble("walk_transit_intercept")
                    else 0.0
                )
              }
            }

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit = {
              BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit(
                params = BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.MulitnomialLogit
                  .Params(c.getConfig("params"))
              )
            }
          }

          def apply(
            c: com.typesafe.config.Config
          ): BeamConfig.Beam.Agentsim.Agents.ModalBehaviors = {
            BeamConfig.Beam.Agentsim.Agents.ModalBehaviors(
              defaultValueOfTime =
                if (c.hasPathOrNull("defaultValueOfTime")) c.getDouble("defaultValueOfTime")
                else 18.0,
              lccm = BeamConfig.Beam.Agentsim.Agents.ModalBehaviors.Lccm(c.getConfig("lccm")),
              modeChoiceClass =
                if (c.hasPathOrNull("modeChoiceClass")) c.getString("modeChoiceClass")
                else "ModeChoiceMultinomialLogit",
              mulitnomialLogit = BeamConfig.Beam.Agentsim.Agents.ModalBehaviors
                .MulitnomialLogit(c.getConfig("mulitnomialLogit"))
            )
          }
        }

        case class RideHail(
          allocationManager: BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager,
          defaultCostPerMile: scala.Double,
          defaultCostPerMinute: scala.Double,
          initialLocation: BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation,
          iterationStats: BeamConfig.Beam.Agentsim.Agents.RideHail.IterationStats,
          numDriversAsFractionOfPopulation: scala.Double,
          rideHailManager: BeamConfig.Beam.Agentsim.Agents.RideHail.RideHailManager,
          surgePricing: BeamConfig.Beam.Agentsim.Agents.RideHail.SurgePricing
        )

        object RideHail {
          case class AllocationManager(
            name: java.lang.String,
            randomRepositioning: BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager.RandomRepositioning,
            repositionLowWaitingTimes: BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager.RepositionLowWaitingTimes,
            timeoutInSeconds: scala.Int
          )

          object AllocationManager {
            case class RandomRepositioning(
              repositioningShare: scala.Double
            )

            object RandomRepositioning {

              def apply(
                c: com.typesafe.config.Config
              ): BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager.RandomRepositioning = {
                BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager.RandomRepositioning(
                  repositioningShare =
                    if (c.hasPathOrNull("repositioningShare")) c.getDouble("repositioningShare")
                    else 0.1
                )
              }
            }

            case class RepositionLowWaitingTimes(
              allowIncreasingRadiusIfDemandInRadiusLow: scala.Boolean,
              demandWeight: scala.Double,
              distanceWeight: scala.Double,
              keepMaxTopNScores: scala.Int,
              minDemandPercentageInRadius: scala.Double,
              minScoreThresholdForRepositioning: scala.Double,
              minimumNumberOfIdlingVehiclesThresholdForRepositioning: scala.Int,
              percentageOfVehiclesToReposition: scala.Double,
              produceDebugImages: scala.Boolean,
              repositionCircleRadiusInMeters: scala.Double,
              repositioningMethod: java.lang.String,
              timeWindowSizeInSecForDecidingAboutRepositioning: scala.Double,
              waitingTimeWeight: scala.Double
            )

            object RepositionLowWaitingTimes {

              def apply(
                c: com.typesafe.config.Config
              ): BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager.RepositionLowWaitingTimes = {
                BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager
                  .RepositionLowWaitingTimes(
                    allowIncreasingRadiusIfDemandInRadiusLow = !c.hasPathOrNull(
                      "allowIncreasingRadiusIfDemandInRadiusLow"
                    ) || c.getBoolean("allowIncreasingRadiusIfDemandInRadiusLow"),
                    demandWeight =
                      if (c.hasPathOrNull("demandWeight")) c.getDouble("demandWeight") else 4.0,
                    distanceWeight =
                      if (c.hasPathOrNull("distanceWeight")) c.getDouble("distanceWeight")
                      else 0.01,
                    keepMaxTopNScores =
                      if (c.hasPathOrNull("keepMaxTopNScores")) c.getInt("keepMaxTopNScores")
                      else 1,
                    minDemandPercentageInRadius =
                      if (c.hasPathOrNull("minDemandPercentageInRadius"))
                        c.getDouble("minDemandPercentageInRadius")
                      else 0.1,
                    minScoreThresholdForRepositioning =
                      if (c.hasPathOrNull("minScoreThresholdForRepositioning"))
                        c.getDouble("minScoreThresholdForRepositioning")
                      else 0.1,
                    minimumNumberOfIdlingVehiclesThresholdForRepositioning =
                      if (c.hasPathOrNull("minimumNumberOfIdlingVehiclesThresholdForRepositioning"))
                        c.getInt("minimumNumberOfIdlingVehiclesThresholdForRepositioning")
                      else 1,
                    percentageOfVehiclesToReposition =
                      if (c.hasPathOrNull("percentageOfVehiclesToReposition"))
                        c.getDouble("percentageOfVehiclesToReposition")
                      else 0.01,
                    produceDebugImages = !c.hasPathOrNull("produceDebugImages") || c.getBoolean(
                      "produceDebugImages"
                    ),
                    repositionCircleRadiusInMeters =
                      if (c.hasPathOrNull("repositionCircleRadiusInMeters"))
                        c.getDouble("repositionCircleRadiusInMeters")
                      else 3000,
                    repositioningMethod =
                      if (c.hasPathOrNull("repositioningMethod")) c.getString("repositioningMethod")
                      else "TOP_SCORES",
                    timeWindowSizeInSecForDecidingAboutRepositioning =
                      if (c.hasPathOrNull("timeWindowSizeInSecForDecidingAboutRepositioning"))
                        c.getDouble("timeWindowSizeInSecForDecidingAboutRepositioning")
                      else 1200,
                    waitingTimeWeight =
                      if (c.hasPathOrNull("waitingTimeWeight")) c.getDouble("waitingTimeWeight")
                      else 4.0
                  )
              }
            }

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager = {
              BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager(
                name = if (c.hasPathOrNull("name")) c.getString("name") else "DEFAULT_MANAGER",
                randomRepositioning = BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager
                  .RandomRepositioning(c.getConfig("randomRepositioning")),
                repositionLowWaitingTimes =
                  BeamConfig.Beam.Agentsim.Agents.RideHail.AllocationManager
                    .RepositionLowWaitingTimes(c.getConfig("repositionLowWaitingTimes")),
                timeoutInSeconds =
                  if (c.hasPathOrNull("timeoutInSeconds")) c.getInt("timeoutInSeconds") else 120
              )
            }
          }

          case class InitialLocation(
            home: BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation.Home,
            name: java.lang.String
          )

          object InitialLocation {
            case class Home(
              radiusInMeters: scala.Double
            )

            object Home {

              def apply(
                c: com.typesafe.config.Config
              ): BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation.Home = {
                BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation.Home(
                  radiusInMeters =
                    if (c.hasPathOrNull("radiusInMeters")) c.getDouble("radiusInMeters") else 10000
                )
              }
            }

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation = {
              BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation(
                home = BeamConfig.Beam.Agentsim.Agents.RideHail.InitialLocation
                  .Home(c.getConfig("home")),
                name = if (c.hasPathOrNull("name")) c.getString("name") else "HOME"
              )
            }
          }

          case class IterationStats(
            timeBinSizeInSec: scala.Double
          )

          object IterationStats {

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.RideHail.IterationStats = {
              BeamConfig.Beam.Agentsim.Agents.RideHail.IterationStats(
                timeBinSizeInSec =
                  if (c.hasPathOrNull("timeBinSizeInSec")) c.getDouble("timeBinSizeInSec")
                  else 3600.0
              )
            }
          }

          case class RideHailManager(
            radiusInMeters: scala.Double
          )

          object RideHailManager {

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.RideHail.RideHailManager = {
              BeamConfig.Beam.Agentsim.Agents.RideHail.RideHailManager(
                radiusInMeters =
                  if (c.hasPathOrNull("radiusInMeters")) c.getDouble("radiusInMeters") else 5000
              )
            }
          }

          case class SurgePricing(
            minimumSurgeLevel: scala.Double,
            numberOfCategories: scala.Int,
            priceAdjustmentStrategy: java.lang.String,
            surgeLevelAdaptionStep: scala.Double
          )

          object SurgePricing {

            def apply(
              c: com.typesafe.config.Config
            ): BeamConfig.Beam.Agentsim.Agents.RideHail.SurgePricing = {
              BeamConfig.Beam.Agentsim.Agents.RideHail.SurgePricing(
                minimumSurgeLevel =
                  if (c.hasPathOrNull("minimumSurgeLevel")) c.getDouble("minimumSurgeLevel")
                  else 0.1,
                numberOfCategories =
                  if (c.hasPathOrNull("numberOfCategories")) c.getInt("numberOfCategories") else 6,
                priceAdjustmentStrategy =
                  if (c.hasPathOrNull("priceAdjustmentStrategy"))
                    c.getString("priceAdjustmentStrategy")
                  else "KEEP_PRICE_LEVEL_FIXED_AT_ONE",
                surgeLevelAdaptionStep =
                  if (c.hasPathOrNull("surgeLevelAdaptionStep"))
                    c.getDouble("surgeLevelAdaptionStep")
                  else 0.1
              )
            }
          }

          def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Agents.RideHail = {
            BeamConfig.Beam.Agentsim.Agents.RideHail(
              allocationManager = BeamConfig.Beam.Agentsim.Agents.RideHail
                .AllocationManager(c.getConfig("allocationManager")),
              defaultCostPerMile =
                if (c.hasPathOrNull("defaultCostPerMile")) c.getDouble("defaultCostPerMile")
                else 1.25,
              defaultCostPerMinute =
                if (c.hasPathOrNull("defaultCostPerMinute")) c.getDouble("defaultCostPerMinute")
                else 0.75,
              initialLocation = BeamConfig.Beam.Agentsim.Agents.RideHail
                .InitialLocation(c.getConfig("initialLocation")),
              iterationStats = BeamConfig.Beam.Agentsim.Agents.RideHail
                .IterationStats(c.getConfig("iterationStats")),
              numDriversAsFractionOfPopulation =
                if (c.hasPathOrNull("numDriversAsFractionOfPopulation"))
                  c.getDouble("numDriversAsFractionOfPopulation")
                else 0.5,
              rideHailManager = BeamConfig.Beam.Agentsim.Agents.RideHail
                .RideHailManager(c.getConfig("rideHailManager")),
              surgePricing =
                BeamConfig.Beam.Agentsim.Agents.RideHail.SurgePricing(c.getConfig("surgePricing"))
            )
          }
        }

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Agents = {
          BeamConfig.Beam.Agentsim.Agents(
            drivingCost = BeamConfig.Beam.Agentsim.Agents.DrivingCost(c.getConfig("drivingCost")),
            modalBehaviors =
              BeamConfig.Beam.Agentsim.Agents.ModalBehaviors(c.getConfig("modalBehaviors")),
            rideHail = BeamConfig.Beam.Agentsim.Agents.RideHail(c.getConfig("rideHail"))
          )
        }
      }

      case class Taz(
        file: java.lang.String
      )

      object Taz {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Taz = {
          BeamConfig.Beam.Agentsim.Taz(
            file =
              if (c.hasPathOrNull("file")) c.getString("file")
              else "/test/input/beamville/taz-centers.csv"
          )
        }
      }

      case class Toll(
        file: java.lang.String
      )

      object Toll {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Toll = {
          BeamConfig.Beam.Agentsim.Toll(
            file =
              if (c.hasPathOrNull("file")) c.getString("file")
              else "/test/input/beamville/toll-prices.csv"
          )
        }
      }

      case class Tuning(
        fuelCapacityInJoules: scala.Double,
        rideHailPrice: scala.Double,
        tollPrice: scala.Double,
        transitCapacity: scala.Double,
        transitPrice: scala.Double
      )

      object Tuning {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim.Tuning = {
          BeamConfig.Beam.Agentsim.Tuning(
            fuelCapacityInJoules =
              if (c.hasPathOrNull("fuelCapacityInJoules")) c.getDouble("fuelCapacityInJoules")
              else 86400000,
            rideHailPrice =
              if (c.hasPathOrNull("rideHailPrice")) c.getDouble("rideHailPrice") else 1.0,
            tollPrice = if (c.hasPathOrNull("tollPrice")) c.getDouble("tollPrice") else 1.0,
            transitCapacity =
              if (c.hasPathOrNull("transitCapacity")) c.getDouble("transitCapacity") else 1.0,
            transitPrice = if (c.hasPathOrNull("transitPrice")) c.getDouble("transitPrice") else 1.0
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Agentsim = {
        BeamConfig.Beam.Agentsim(
          agents = BeamConfig.Beam.Agentsim.Agents(c.getConfig("agents")),
          numAgents = if (c.hasPathOrNull("numAgents")) c.getInt("numAgents") else 100,
          simulationName =
            if (c.hasPathOrNull("simulationName")) c.getString("simulationName") else "beamville",
          taz = BeamConfig.Beam.Agentsim.Taz(c.getConfig("taz")),
          thresholdForWalkingInMeters =
            if (c.hasPathOrNull("thresholdForWalkingInMeters"))
              c.getInt("thresholdForWalkingInMeters")
            else 100,
          timeBinSize = if (c.hasPathOrNull("timeBinSize")) c.getInt("timeBinSize") else 3600,
          toll = BeamConfig.Beam.Agentsim.Toll(c.getConfig("toll")),
          tuning = BeamConfig.Beam.Agentsim.Tuning(c.getConfig("tuning"))
        )
      }
    }
    case class Calibration(
      objectiveFunction: java.lang.String
    )

    object Calibration {

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Calibration = {
        BeamConfig.Beam.Calibration(
          objectiveFunction =
            if (c.hasPathOrNull("objectiveFunction")) c.getString("objectiveFunction")
            else "ModeChoiceObjectiveFunction"
        )
      }
    }
    case class Debug(
      actor: BeamConfig.Beam.Debug.Actor,
      debugActorTimerIntervalInSec: scala.Int,
      debugEnabled: scala.Boolean,
      secondsToWaitForSkip: scala.Int,
      skipOverBadActors: scala.Boolean
    )

    object Debug {
      case class Actor(
        logDepth: scala.Int
      )

      object Actor {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Debug.Actor = {
          BeamConfig.Beam.Debug.Actor(
            logDepth = if (c.hasPathOrNull("logDepth")) c.getInt("logDepth") else 0
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Debug = {
        BeamConfig.Beam.Debug(
          actor = BeamConfig.Beam.Debug.Actor(c.getConfig("actor")),
          debugActorTimerIntervalInSec =
            if (c.hasPathOrNull("debugActorTimerIntervalInSec"))
              c.getInt("debugActorTimerIntervalInSec")
            else 0,
          debugEnabled = c.hasPathOrNull("debugEnabled") && c.getBoolean("debugEnabled"),
          secondsToWaitForSkip =
            if (c.hasPathOrNull("secondsToWaitForSkip")) c.getInt("secondsToWaitForSkip") else 10,
          skipOverBadActors = c.hasPathOrNull("skipOverBadActors") && c.getBoolean(
            "skipOverBadActors"
          )
        )
      }
    }

    case class Metrics(
      level: java.lang.String
    )

    object Metrics {

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Metrics = {
        BeamConfig.Beam.Metrics(
          level = if (c.hasPathOrNull("level")) c.getString("level") else "verbose"
        )
      }
    }

    case class Outputs(
      addTimestampToOutputDirectory: scala.Boolean,
      baseOutputDirectory: java.lang.String,
      events: BeamConfig.Beam.Outputs.Events,
      stats: BeamConfig.Beam.Outputs.Stats,
      writeEventsInterval: scala.Int,
      writePlansInterval: scala.Int
    )

    object Outputs {
      case class Events(
        defaultWritingLevel: java.lang.String,
        explodeIntoFiles: scala.Boolean,
        fileOutputFormats: java.lang.String,
        overrideWritingLevels: java.lang.String
      )

      object Events {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Outputs.Events = {
          BeamConfig.Beam.Outputs.Events(
            defaultWritingLevel =
              if (c.hasPathOrNull("defaultWritingLevel")) c.getString("defaultWritingLevel")
              else "OFF",
            explodeIntoFiles = c.hasPathOrNull("explodeIntoFiles") && c.getBoolean(
              "explodeIntoFiles"
            ),
            fileOutputFormats =
              if (c.hasPathOrNull("fileOutputFormats")) c.getString("fileOutputFormats") else "csv",
            overrideWritingLevels =
              if (c.hasPathOrNull("overrideWritingLevels")) c.getString("overrideWritingLevels")
              else
                "beam.agentsim.events.ModeChoiceEvent:VERBOSE, beam.agentsim.events.PathTraversalEvent:VERBOSE"
          )
        }
      }

      case class Stats(
        binSize: scala.Int
      )

      object Stats {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Outputs.Stats = {
          BeamConfig.Beam.Outputs.Stats(
            binSize = if (c.hasPathOrNull("binSize")) c.getInt("binSize") else 3600
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Outputs = {
        BeamConfig.Beam.Outputs(
          addTimestampToOutputDirectory = !c.hasPathOrNull("addTimestampToOutputDirectory") || c
            .getBoolean("addTimestampToOutputDirectory"),
          baseOutputDirectory =
            if (c.hasPathOrNull("baseOutputDirectory")) c.getString("baseOutputDirectory")
            else "output",
          events = BeamConfig.Beam.Outputs.Events(c.getConfig("events")),
          stats = BeamConfig.Beam.Outputs.Stats(c.getConfig("stats")),
          writeEventsInterval =
            if (c.hasPathOrNull("writeEventsInterval")) c.getInt("writeEventsInterval") else 1,
          writePlansInterval =
            if (c.hasPathOrNull("writePlansInterval")) c.getInt("writePlansInterval") else 0
        )
      }
    }

    case class Physsim(
      flowCapacityFactor: scala.Double,
      jdeqsim: BeamConfig.Beam.Physsim.Jdeqsim,
      linkStatsBinSize: scala.Int,
      linkStatsWriteInterval: scala.Int,
      ptSampleSize: scala.Double,
      storageCapacityFactor: scala.Double,
      writeEventsInterval: scala.Int,
      writeMATSimNetwork: scala.Boolean,
      writePlansInterval: scala.Int
    )

    object Physsim {
      case class Jdeqsim(
        agentSimPhysSimInterfaceDebugger: BeamConfig.Beam.Physsim.Jdeqsim.AgentSimPhysSimInterfaceDebugger
      )

      object Jdeqsim {
        case class AgentSimPhysSimInterfaceDebugger(
          enabled: scala.Boolean
        )

        object AgentSimPhysSimInterfaceDebugger {

          def apply(
            c: com.typesafe.config.Config
          ): BeamConfig.Beam.Physsim.Jdeqsim.AgentSimPhysSimInterfaceDebugger = {
            BeamConfig.Beam.Physsim.Jdeqsim.AgentSimPhysSimInterfaceDebugger(
              enabled = c.hasPathOrNull("enabled") && c.getBoolean("enabled")
            )
          }
        }

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Physsim.Jdeqsim = {
          BeamConfig.Beam.Physsim.Jdeqsim(
            agentSimPhysSimInterfaceDebugger = BeamConfig.Beam.Physsim.Jdeqsim
              .AgentSimPhysSimInterfaceDebugger(c.getConfig("agentSimPhysSimInterfaceDebugger"))
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Physsim = {
        BeamConfig.Beam.Physsim(
          flowCapacityFactor =
            if (c.hasPathOrNull("flowCapacityFactor")) c.getDouble("flowCapacityFactor") else 1.0,
          jdeqsim = BeamConfig.Beam.Physsim.Jdeqsim(c.getConfig("jdeqsim")),
          linkStatsBinSize =
            if (c.hasPathOrNull("linkStatsBinSize")) c.getInt("linkStatsBinSize") else 3600,
          linkStatsWriteInterval =
            if (c.hasPathOrNull("linkStatsWriteInterval")) c.getInt("linkStatsWriteInterval")
            else 1,
          ptSampleSize = if (c.hasPathOrNull("ptSampleSize")) c.getDouble("ptSampleSize") else 1.0,
          storageCapacityFactor =
            if (c.hasPathOrNull("storageCapacityFactor")) c.getDouble("storageCapacityFactor")
            else 1.0,
          writeEventsInterval =
            if (c.hasPathOrNull("writeEventsInterval")) c.getInt("writeEventsInterval") else 0,
          writeMATSimNetwork = c.hasPathOrNull("writeMATSimNetwork") && c.getBoolean(
            "writeMATSimNetwork"
          ),
          writePlansInterval =
            if (c.hasPathOrNull("writePlansInterval")) c.getInt("writePlansInterval") else 0
        )
      }
    }

    case class Routing(
      baseDate: java.lang.String,
      gtfs: BeamConfig.Beam.Routing.Gtfs,
      r5: BeamConfig.Beam.Routing.R5,
      transitOnStreetNetwork: scala.Boolean
    )

    object Routing {
      case class Gtfs(
        crs: java.lang.String,
        operatorsFile: java.lang.String,
        outputDir: java.lang.String
      )

      object Gtfs {

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Routing.Gtfs = {
          BeamConfig.Beam.Routing.Gtfs(
            crs = if (c.hasPathOrNull("crs")) c.getString("crs") else "epsg:26910",
            operatorsFile =
              if (c.hasPathOrNull("operatorsFile")) c.getString("operatorsFile")
              else "src/main/resources/GTFSOperators.csv",
            outputDir =
              if (c.hasPathOrNull("outputDir")) c.getString("outputDir") else "output/gtfs"
          )
        }
      }

      case class R5(
        departureWindow: scala.Double,
        directory: java.lang.String,
        mNetBuilder: BeamConfig.Beam.Routing.R5.MNetBuilder,
        numberOfSamples: scala.Int,
        osmFile: java.lang.String,
        osmMapdbFile: java.lang.String
      )

      object R5 {
        case class MNetBuilder(
          fromCRS: java.lang.String,
          toCRS: java.lang.String
        )

        object MNetBuilder {

          def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Routing.R5.MNetBuilder = {
            BeamConfig.Beam.Routing.R5.MNetBuilder(
              fromCRS = if (c.hasPathOrNull("fromCRS")) c.getString("fromCRS") else "EPSG:4326",
              toCRS = if (c.hasPathOrNull("toCRS")) c.getString("toCRS") else "EPSG:26910"
            )
          }
        }

        def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Routing.R5 = {
          BeamConfig.Beam.Routing.R5(
            departureWindow =
              if (c.hasPathOrNull("departureWindow")) c.getDouble("departureWindow") else 15.0,
            directory =
              if (c.hasPathOrNull("directory")) c.getString("directory")
              else "/test/input/beamville/r5",
            mNetBuilder = BeamConfig.Beam.Routing.R5.MNetBuilder(c.getConfig("mNetBuilder")),
            numberOfSamples =
              if (c.hasPathOrNull("numberOfSamples")) c.getInt("numberOfSamples") else 1,
            osmFile =
              if (c.hasPathOrNull("osmFile")) c.getString("osmFile")
              else "/test/input/beamville/r5/beamville.osm.pbf",
            osmMapdbFile =
              if (c.hasPathOrNull("osmMapdbFile")) c.getString("osmMapdbFile")
              else "/test/input/beamville/r5/osm.mapdb"
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Routing = {
        BeamConfig.Beam.Routing(
          baseDate =
            if (c.hasPathOrNull("baseDate")) c.getString("baseDate")
            else "2016-10-17T00:00:00-07:00",
          gtfs = BeamConfig.Beam.Routing.Gtfs(c.getConfig("gtfs")),
          r5 = BeamConfig.Beam.Routing.R5(c.getConfig("r5")),
          transitOnStreetNetwork = !c.hasPathOrNull("transitOnStreetNetwork") || c.getBoolean(
            "transitOnStreetNetwork"
          )
        )
      }
    }

    case class Spatial(
      boundingBoxBuffer: scala.Int,
      localCRS: java.lang.String
    )

    object Spatial {

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.Spatial = {
        BeamConfig.Beam.Spatial(
          boundingBoxBuffer =
            if (c.hasPathOrNull("boundingBoxBuffer")) c.getInt("boundingBoxBuffer") else 5000,
          localCRS = if (c.hasPathOrNull("localCRS")) c.getString("localCRS") else "epsg:32631"
        )
      }
    }

    case class WarmStart(
      enabled: scala.Boolean,
      path: java.lang.String,
      pathType: java.lang.String
    )

    object WarmStart {

      def apply(c: com.typesafe.config.Config): BeamConfig.Beam.WarmStart = {
        BeamConfig.Beam.WarmStart(
          enabled = c.hasPathOrNull("enabled") && c.getBoolean("enabled"),
          path = if (c.hasPathOrNull("path")) c.getString("path") else "output",
          pathType = if (c.hasPathOrNull("pathType")) c.getString("pathType") else "PARENT_RUN"
        )
      }
    }

    def apply(c: com.typesafe.config.Config): BeamConfig.Beam = {
      BeamConfig.Beam(
        agentsim = BeamConfig.Beam.Agentsim(c.getConfig("agentsim")),
        calibration = BeamConfig.Beam.Calibration(c.getConfig("calibration")),
        debug = BeamConfig.Beam.Debug(c.getConfig("debug")),
        inputDirectory =
          if (c.hasPathOrNull("inputDirectory")) c.getString("inputDirectory")
          else "/test/input/beamville",
        metrics = BeamConfig.Beam.Metrics(c.getConfig("metrics")),
        outputs = BeamConfig.Beam.Outputs(c.getConfig("outputs")),
        physsim = BeamConfig.Beam.Physsim(c.getConfig("physsim")),
        routing = BeamConfig.Beam.Routing(c.getConfig("routing")),
        spatial = BeamConfig.Beam.Spatial(c.getConfig("spatial")),
        warmStart = BeamConfig.Beam.WarmStart(c.getConfig("warmStart"))
      )
    }
  }

  case class Matsim(
    modules: BeamConfig.Matsim.Modules
  )

  object Matsim {
    case class Modules(
      changeMode: BeamConfig.Matsim.Modules.ChangeMode,
      controler: BeamConfig.Matsim.Modules.Controler,
      counts: BeamConfig.Matsim.Modules.Counts,
      global: BeamConfig.Matsim.Modules.Global,
      households: BeamConfig.Matsim.Modules.Households,
      network: BeamConfig.Matsim.Modules.Network,
      parallelEventHandling: BeamConfig.Matsim.Modules.ParallelEventHandling,
      planCalcScore: BeamConfig.Matsim.Modules.PlanCalcScore,
      plans: BeamConfig.Matsim.Modules.Plans,
      qsim: BeamConfig.Matsim.Modules.Qsim,
      strategy: BeamConfig.Matsim.Modules.Strategy,
      transit: BeamConfig.Matsim.Modules.Transit,
      vehicles: BeamConfig.Matsim.Modules.Vehicles
    )

    object Modules {
      case class ChangeMode(
        modes: java.lang.String
      )

      object ChangeMode {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.ChangeMode = {
          BeamConfig.Matsim.Modules.ChangeMode(
            modes = if (c.hasPathOrNull("modes")) c.getString("modes") else "car,pt"
          )
        }
      }

      case class Controler(
        eventsFileFormat: java.lang.String,
        firstIteration: scala.Int,
        lastIteration: scala.Int,
        mobsim: java.lang.String,
        outputDirectory: java.lang.String,
        overwriteFiles: java.lang.String
      )

      object Controler {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Controler = {
          BeamConfig.Matsim.Modules.Controler(
            eventsFileFormat =
              if (c.hasPathOrNull("eventsFileFormat")) c.getString("eventsFileFormat") else "xml",
            firstIteration =
              if (c.hasPathOrNull("firstIteration")) c.getInt("firstIteration") else 0,
            lastIteration = if (c.hasPathOrNull("lastIteration")) c.getInt("lastIteration") else 0,
            mobsim = if (c.hasPathOrNull("mobsim")) c.getString("mobsim") else "metasim",
            outputDirectory =
              if (c.hasPathOrNull("outputDirectory")) c.getString("outputDirectory")
              else "output/pt-tutorial",
            overwriteFiles =
              if (c.hasPathOrNull("overwriteFiles")) c.getString("overwriteFiles")
              else "overwriteExistingFiles"
          )
        }
      }

      case class Counts(
        averageCountsOverIterations: scala.Int,
        countsScaleFactor: scala.Double,
        inputCountsFile: java.lang.String,
        outputformat: java.lang.String,
        writeCountsInterval: scala.Int
      )

      object Counts {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Counts = {
          BeamConfig.Matsim.Modules.Counts(
            averageCountsOverIterations =
              if (c.hasPathOrNull("averageCountsOverIterations"))
                c.getInt("averageCountsOverIterations")
              else 0,
            countsScaleFactor =
              if (c.hasPathOrNull("countsScaleFactor")) c.getDouble("countsScaleFactor")
              else 10.355,
            inputCountsFile =
              if (c.hasPathOrNull("inputCountsFile")) c.getString("inputCountsFile") else "",
            outputformat =
              if (c.hasPathOrNull("outputformat")) c.getString("outputformat") else "all",
            writeCountsInterval =
              if (c.hasPathOrNull("writeCountsInterval")) c.getInt("writeCountsInterval") else 0
          )
        }
      }

      case class Global(
        coordinateSystem: java.lang.String,
        randomSeed: scala.Int
      )

      object Global {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Global = {
          BeamConfig.Matsim.Modules.Global(
            coordinateSystem =
              if (c.hasPathOrNull("coordinateSystem")) c.getString("coordinateSystem")
              else "Atlantis",
            randomSeed = if (c.hasPathOrNull("randomSeed")) c.getInt("randomSeed") else 4711
          )
        }
      }

      case class Households(
        inputFile: java.lang.String,
        inputHouseholdAttributesFile: java.lang.String
      )

      object Households {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Households = {
          BeamConfig.Matsim.Modules.Households(
            inputFile =
              if (c.hasPathOrNull("inputFile")) c.getString("inputFile")
              else "/test/input/beamville/households.xml",
            inputHouseholdAttributesFile =
              if (c.hasPathOrNull("inputHouseholdAttributesFile"))
                c.getString("inputHouseholdAttributesFile")
              else "/test/input/beamville/householdAttributes.xml"
          )
        }
      }

      case class Network(
        inputNetworkFile: java.lang.String
      )

      object Network {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Network = {
          BeamConfig.Matsim.Modules.Network(
            inputNetworkFile =
              if (c.hasPathOrNull("inputNetworkFile")) c.getString("inputNetworkFile")
              else "/test/input/beamville/physsim-network.xml"
          )
        }
      }

      case class ParallelEventHandling(
        estimatedNumberOfEvents: scala.Int,
        numberOfThreads: scala.Int,
        oneThreadPerHandler: scala.Boolean,
        synchronizeOnSimSteps: scala.Boolean
      )

      object ParallelEventHandling {

        def apply(
          c: com.typesafe.config.Config
        ): BeamConfig.Matsim.Modules.ParallelEventHandling = {
          BeamConfig.Matsim.Modules.ParallelEventHandling(
            estimatedNumberOfEvents =
              if (c.hasPathOrNull("estimatedNumberOfEvents")) c.getInt("estimatedNumberOfEvents")
              else 1000000000,
            numberOfThreads =
              if (c.hasPathOrNull("numberOfThreads")) c.getInt("numberOfThreads") else 1,
            oneThreadPerHandler = c.hasPathOrNull("oneThreadPerHandler") && c.getBoolean(
              "oneThreadPerHandler"
            ),
            synchronizeOnSimSteps = c.hasPathOrNull("synchronizeOnSimSteps") && c.getBoolean(
              "synchronizeOnSimSteps"
            )
          )
        }
      }

      case class PlanCalcScore(
        BrainExpBeta: scala.Long,
        earlyDeparture: scala.Long,
        lateArrival: scala.Long,
        learningRate: scala.Long,
        parameterset: scala.List[BeamConfig.Matsim.Modules.PlanCalcScore.Parameterset$Elm],
        performing: scala.Long,
        traveling: scala.Long,
        waiting: scala.Long
      )

      object PlanCalcScore {
        case class Parameterset$Elm(
          activityType: java.lang.String,
          priority: scala.Int,
          scoringThisActivityAtAll: scala.Boolean,
          `type`: java.lang.String,
          typicalDuration: java.lang.String,
          typicalDurationScoreComputation: java.lang.String
        )

        object Parameterset$Elm {

          def apply(
            c: com.typesafe.config.Config
          ): BeamConfig.Matsim.Modules.PlanCalcScore.Parameterset$Elm = {
            BeamConfig.Matsim.Modules.PlanCalcScore.Parameterset$Elm(
              activityType =
                if (c.hasPathOrNull("activityType")) c.getString("activityType") else "Home",
              priority = if (c.hasPathOrNull("priority")) c.getInt("priority") else 1,
              scoringThisActivityAtAll = !c.hasPathOrNull("scoringThisActivityAtAll") || c
                .getBoolean("scoringThisActivityAtAll"),
              `type` = if (c.hasPathOrNull("type")) c.getString("type") else "activityParams",
              typicalDuration =
                if (c.hasPathOrNull("typicalDuration")) c.getString("typicalDuration")
                else "01:00:00",
              typicalDurationScoreComputation =
                if (c.hasPathOrNull("typicalDurationScoreComputation"))
                  c.getString("typicalDurationScoreComputation")
                else "uniform"
            )
          }
        }

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.PlanCalcScore = {
          BeamConfig.Matsim.Modules.PlanCalcScore(
            BrainExpBeta =
              if (c.hasPathOrNull("BrainExpBeta"))
                c.getDuration("BrainExpBeta", java.util.concurrent.TimeUnit.MILLISECONDS)
              else 2,
            earlyDeparture =
              if (c.hasPathOrNull("earlyDeparture"))
                c.getDuration("earlyDeparture", java.util.concurrent.TimeUnit.MILLISECONDS)
              else 0,
            lateArrival =
              if (c.hasPathOrNull("lateArrival"))
                c.getDuration("lateArrival", java.util.concurrent.TimeUnit.MILLISECONDS)
              else -18,
            learningRate =
              if (c.hasPathOrNull("learningRate"))
                c.getDuration("learningRate", java.util.concurrent.TimeUnit.MILLISECONDS)
              else 1,
            parameterset = $_LBeamConfig_Matsim_Modules_PlanCalcScore_Parameterset$Elm(
              c.getList("parameterset")
            ),
            performing =
              if (c.hasPathOrNull("performing"))
                c.getDuration("performing", java.util.concurrent.TimeUnit.MILLISECONDS)
              else 6,
            traveling =
              if (c.hasPathOrNull("traveling"))
                c.getDuration("traveling", java.util.concurrent.TimeUnit.MILLISECONDS)
              else -6,
            waiting =
              if (c.hasPathOrNull("waiting"))
                c.getDuration("waiting", java.util.concurrent.TimeUnit.MILLISECONDS)
              else 0
          )
        }
        private def $_LBeamConfig_Matsim_Modules_PlanCalcScore_Parameterset$Elm(
          cl: com.typesafe.config.ConfigList
        ): scala.List[BeamConfig.Matsim.Modules.PlanCalcScore.Parameterset$Elm] = {
          import scala.collection.JavaConverters._
          cl.asScala
            .map(
              cv =>
                BeamConfig.Matsim.Modules.PlanCalcScore
                  .Parameterset$Elm(cv.asInstanceOf[com.typesafe.config.ConfigObject].toConfig)
            )
            .toList
        }
      }

      case class Plans(
        inputPersonAttributesFile: java.lang.String,
        inputPlansFile: java.lang.String
      )

      object Plans {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Plans = {
          BeamConfig.Matsim.Modules.Plans(
            inputPersonAttributesFile =
              if (c.hasPathOrNull("inputPersonAttributesFile"))
                c.getString("inputPersonAttributesFile")
              else "/test/input/beamville/populationAttributes.xml",
            inputPlansFile =
              if (c.hasPathOrNull("inputPlansFile")) c.getString("inputPlansFile")
              else "/test/input/beamville/population.xml"
          )
        }
      }

      case class Qsim(
        endTime: java.lang.String,
        snapshotperiod: java.lang.String,
        startTime: java.lang.String
      )

      object Qsim {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Qsim = {
          BeamConfig.Matsim.Modules.Qsim(
            endTime = if (c.hasPathOrNull("endTime")) c.getString("endTime") else "30:00:00",
            snapshotperiod =
              if (c.hasPathOrNull("snapshotperiod")) c.getString("snapshotperiod") else "00:00:00",
            startTime = if (c.hasPathOrNull("startTime")) c.getString("startTime") else "00:00:00"
          )
        }
      }

      case class Strategy(
        ModuleProbability_1: scala.Double,
        ModuleProbability_3: scala.Double,
        Module_1: java.lang.String,
        Module_3: java.lang.String,
        maxAgentPlanMemorySize: scala.Int
      )

      object Strategy {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Strategy = {
          BeamConfig.Matsim.Modules.Strategy(
            ModuleProbability_1 =
              if (c.hasPathOrNull("ModuleProbability_1")) c.getDouble("ModuleProbability_1")
              else 0.7,
            ModuleProbability_3 =
              if (c.hasPathOrNull("ModuleProbability_3")) c.getDouble("ModuleProbability_3")
              else 0.1,
            Module_1 = if (c.hasPathOrNull("Module_1")) c.getString("Module_1") else "BestScore",
            Module_3 =
              if (c.hasPathOrNull("Module_3")) c.getString("Module_3") else "TimeAllocationMutator",
            maxAgentPlanMemorySize =
              if (c.hasPathOrNull("maxAgentPlanMemorySize")) c.getInt("maxAgentPlanMemorySize")
              else 5
          )
        }
      }

      case class Transit(
        transitModes: java.lang.String,
        useTransit: scala.Boolean,
        vehiclesFile: java.lang.String
      )

      object Transit {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Transit = {
          BeamConfig.Matsim.Modules.Transit(
            transitModes =
              if (c.hasPathOrNull("transitModes")) c.getString("transitModes") else "pt",
            useTransit = c.hasPathOrNull("useTransit") && c.getBoolean("useTransit"),
            vehiclesFile =
              if (c.hasPathOrNull("vehiclesFile")) c.getString("vehiclesFile")
              else "/test/input/beamville/transitVehicles.xml"
          )
        }
      }

      case class Vehicles(
        vehiclesFile: java.lang.String
      )

      object Vehicles {

        def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules.Vehicles = {
          BeamConfig.Matsim.Modules.Vehicles(
            vehiclesFile =
              if (c.hasPathOrNull("vehiclesFile")) c.getString("vehiclesFile")
              else "/test/input/beamville/vehicles.xml"
          )
        }
      }

      def apply(c: com.typesafe.config.Config): BeamConfig.Matsim.Modules = {
        BeamConfig.Matsim.Modules(
          changeMode = BeamConfig.Matsim.Modules.ChangeMode(c.getConfig("changeMode")),
          controler = BeamConfig.Matsim.Modules.Controler(c.getConfig("controler")),
          counts = BeamConfig.Matsim.Modules.Counts(c.getConfig("counts")),
          global = BeamConfig.Matsim.Modules.Global(c.getConfig("global")),
          households = BeamConfig.Matsim.Modules.Households(c.getConfig("households")),
          network = BeamConfig.Matsim.Modules.Network(c.getConfig("network")),
          parallelEventHandling =
            BeamConfig.Matsim.Modules.ParallelEventHandling(c.getConfig("parallelEventHandling")),
          planCalcScore = BeamConfig.Matsim.Modules.PlanCalcScore(c.getConfig("planCalcScore")),
          plans = BeamConfig.Matsim.Modules.Plans(c.getConfig("plans")),
          qsim = BeamConfig.Matsim.Modules.Qsim(c.getConfig("qsim")),
          strategy = BeamConfig.Matsim.Modules.Strategy(c.getConfig("strategy")),
          transit = BeamConfig.Matsim.Modules.Transit(c.getConfig("transit")),
          vehicles = BeamConfig.Matsim.Modules.Vehicles(c.getConfig("vehicles"))
        )
      }
    }

    def apply(c: com.typesafe.config.Config): BeamConfig.Matsim = {
      BeamConfig.Matsim(
        modules = BeamConfig.Matsim.Modules(c.getConfig("modules"))
      )
    }
  }

  def apply(c: com.typesafe.config.Config): BeamConfig = {
    BeamConfig(
      beam = BeamConfig.Beam(c.getConfig("beam")),
      matsim = BeamConfig.Matsim(c.getConfig("matsim"))
    )
  }
}
