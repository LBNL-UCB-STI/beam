##################################################################
# EXPERIMENTAL
##################################################################
beam.experimental.optimizer.enabled = "boolean | false"
##################################################################
# EXECUTION
##################################################################
beam.cluster.enabled = "boolean | false"
beam.actorSystemName = "string | ClusterSystem"
beam.cluster.clusterType = "String? |"
beam.useLocalWorker = "boolean | true"

##################################################################
# SIMULATION
##################################################################
beam.inputDirectory = "/test/input/beamville"
# For subsequential beam runs (some data will be laoded from the latest found run in this directory)
beam.input.lastBaseOutputDir = ${beam.outputs.baseOutputDirectory}
# This prefix is used to find the last run output directory within beam.input.lastBaseOutputDir direcotry
beam.input.simulationPrefix = ${beam.agentsim.simulationName}

beam.agentsim.simulationName = "beamville"
beam.agentsim.randomSeedForPopulationSampling = "int?"
beam.agentsim.agentSampleSizeAsFractionOfPopulation = "double | 1.0"
beam.agentsim.fractionOfPlansWithSingleActivity = "double | 0.0"
beam.agentsim.thresholdForWalkingInMeters = 100
beam.agentsim.thresholdForMakingParkingChoiceInMeters = 100
beam.agentsim.schedulerParallelismWindow = "int | 30"
beam.agentsim.timeBinSize = "int | 3600"
beam.agentsim.firstIteration = "int | 0"
beam.agentsim.lastIteration = "int | 0"
beam.agentsim.endTime = "30:00:00"
beam.agentsim.scheduleMonitorTask.initialDelay = 1
beam.agentsim.scheduleMonitorTask.interval = 30
beam.agentsim.snapLocationAndRemoveInvalidInputs = "boolean | false"

beam.agentsim.agents.bodyType = "BODY-TYPE-DEFAULT"

# TERMINATION CRITERION NAME OPTIONS:
# TerminateAtFixedIterationNumber TerminateAtRideHailFleetStoredElectricityConvergence
beam.sim.termination.criterionName = "TerminateAtFixedIterationNumber"
beam.sim.termination.terminateAtRideHailFleetStoredElectricityConvergence.minLastIteration = "int | 0"
beam.sim.termination.terminateAtRideHailFleetStoredElectricityConvergence.maxLastIteration = "int | 0"
beam.sim.termination.terminateAtRideHailFleetStoredElectricityConvergence.relativeTolerance = "double | 0.01"


# MODE CHOICE OPTIONS:
# ModeChoiceMultinomialLogit ModeChoiceTransitIfAvailable ModeChoiceDriveIfAvailable ModeChoiceRideHailIfAvailable
# ModeChoiceUniformRandom ModeChoiceLCCM
beam.agentsim.agents.modalBehaviors.modeChoiceClass = "ModeChoiceMultinomialLogit"
beam.agentsim.agents.modalBehaviors.maximumNumberOfReplanningAttempts = 3
beam.agentsim.agents.modalBehaviors.defaultValueOfTime = "double | 8.0"
beam.agentsim.agents.modalBehaviors.minimumValueOfTime = "double | 7.25"
# The types have to be in sync with file pointed in the parameter `beam.agentsim.agents.vehicles.vehicleTypesFilePath`
# ["BUS-DEFAULT:1.0","RAIL-DEFAULT:1.0","FERRY-DEFAULT:1.0","SUBWAY-DEFAULT:1.0","CABLE_CAR-DEFAULT:1.0","TRAM-DEFAULT:1.0"]
#@optional
beam.agentsim.agents.modalBehaviors.transitVehicleTypeVOTMultipliers = [string] | []
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.transit = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.bike = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.walk = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHail = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHailPooled = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHailTransit = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.waiting = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.CAV = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.drive = "double | 1.0"
beam.agentsim.agents.modalBehaviors.overrideAutomationLevel = "int | 1"
beam.agentsim.agents.modalBehaviors.overrideAutomationForVOTT = "boolean | false"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.bikeMultiplier.commute.ageGT50 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.bikeMultiplier.noncommute.ageGT50 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.bikeMultiplier.commute.ageLE50 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.bikeMultiplier.noncommute.ageLE50 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.transfer = "double | -1.4"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.transit_crowding = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.transit_crowding_percentile = "double | 90.0"
# any positive value
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.transit_crowding_VOT_multiplier = "double | 0.0"
# from 0 to 1.
# how full should be a vehicle to turn on crowding calculation. 0 - empty, 1 - full
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.transit_crowding_VOT_threshold = "double | 0.5"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.car_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.cav_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.walk_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.drive_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.ride_hail_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.ride_hail_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.ride_hail_pooled_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.walk_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.bike_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.params.bike_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.multinomialLogit.utility_scale_factor = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lccm.filePath = ${beam.inputDirectory}"/lccm-long.csv"

## SECONDARY ACTIVITIES GENERATION
# Allow/disallow generation of secondary activities
beam.agentsim.agents.tripBehaviors.multinomialLogit.generate_secondary_activities = "boolean | false"
# Input file giving the relative likelihoods of starting different activities at different times of the day
beam.agentsim.agents.tripBehaviors.multinomialLogit.intercept_file_path = ""
# Input file giving parameters for the different activity types, including mean duration (duration is drawn from an
# exponential distribution with that mean) and value of time multiplier. The value of time multiplier modifies how
# willing agents are to incur travel time and cost in order to accomplish that activity. For example, a value of 0.5
# means that they get 50% more value out of participating in that activity than they would being at home or work.
# So, if it's a 30 minute activity, they would on average be willing to spend 15 minutes round trip to participate in
# it. If the value is 2, they get 200% more value, so on average they would be willing to spend 60 minutes round trip
# commuting to participate in this activity.
#
# You can adjust the VOT values up or down to get more or less of a given activity
beam.agentsim.agents.tripBehaviors.multinomialLogit.activity_file_path = ""
#This is an intercept value you can add to make all secondary activities more or less likely
beam.agentsim.agents.tripBehaviors.multinomialLogit.additional_trip_utility = "double | 0.0"
# This sets a maximum distance in looking for places to participate in secondary activities. Increasing it
# increases the maximum and mean trip distance for secondary activities.
beam.agentsim.agents.tripBehaviors.multinomialLogit.max_destination_distance_meters = "double | 32000"
# This determines how many options for secondary activity locations an agent chooses between. Increasing this
# number decreases the mean distance traveled to secondary activities and slightly increases the number of trips
# that are made (because the agents are more likely to find a suitable location for a secondary activity nearby)
beam.agentsim.agents.tripBehaviors.multinomialLogit.max_destination_choice_set_size = "int | 20"
#These three values should all be between zero and one and determine the amount of noise in each level of
# the nested choice process. Increasing destination_nest_scale_factor means that people are more likely to
# choose a less optimal destination, mode_nest_scale_factor means people are more likely to value destinations
# accessible by multiple modes, and trip_nest_scale_factor means that people are more likely to take secondary
# trips even if the costs are greater than the benefits
beam.agentsim.agents.tripBehaviors.multinomialLogit.destination_nest_scale_factor = "double | 1.0"
beam.agentsim.agents.tripBehaviors.multinomialLogit.mode_nest_scale_factor = "double | 1.0"
beam.agentsim.agents.tripBehaviors.multinomialLogit.trip_nest_scale_factor = "double | 1.0"
beam.agentsim.agents.tripBehaviors.carUsage.minDistanceToTrainStop = "double | 0.0"


beam.agentsim.agents.modeIncentive.filePath = ""
beam.agentsim.agents.ptFare.filePath = ""
beam.agentsim.agents.parking.multinomialLogit.params.rangeAnxietyMultiplier = "double | -0.5"   # fit range anxiety between [-1, 0]
beam.agentsim.agents.parking.multinomialLogit.params.distanceMultiplier = "double | -0.086"     # based on 20m walk, VoT = $35/hr should be u=-1.0
beam.agentsim.agents.parking.multinomialLogit.params.parkingPriceMultiplier = "double | -0.005" # based on avg. parking prices up to $200!
beam.agentsim.agents.parking.multinomialLogit.params.homeActivityPrefersResidentialParkingMultiplier = "double | 1.0" # positive boost of 1.0 if true
beam.agentsim.agents.parking.multinomialLogit.params.enrouteDetourMultiplier = "double | -0.05" # based on skim travel time and the defined VoT from modalBehaviors and income
beam.agentsim.agents.parking.rangeAnxietyBuffer = "double | 20000.0" # if our remaining range exceeds our remaining tour plus this many meters, then we feel no anxiety; default 20k
beam.agentsim.agents.parking.minSearchRadius = "double | 250.00"  # something small enough that, on average, we see 2 orders of magnitude of samples at most
beam.agentsim.agents.parking.maxSearchRadius = "double | 8046.72" # something large enough that we do not strand our drivers in an oasis
beam.agentsim.agents.parking.searchMaxDistanceRelativeToEllipseFoci = "double | 4.0" # something large enough that we do not travel longer than the actual distance to destination
beam.agentsim.agents.parking.estimatedMinParkingDurationInSeconds = "double | 60.0" # in seconds, something small enough but has meaningful impact on pricing
beam.agentsim.agents.parking.estimatedMeanEnRouteChargingDurationInSeconds = "double | 1800.0" # 80% of the battery charges in 30min
beam.agentsim.agents.parking.fractionOfSameTypeZones = "double | 0.5"
beam.agentsim.agents.parking.minNumberOfSameTypeZones = "int | 10"
beam.agentsim.agents.parking.forceParkingType = "boolean | false"

#TAZ params
beam.agentsim.taz.filePath = ${beam.inputDirectory}"/taz-centers.csv"
beam.agentsim.taz.tazIdFieldName = "tazId"
beam.agentsim.taz.parkingFilePath = ""
beam.agentsim.taz.parkingStallCountScalingFactor = "double | 1.0"
beam.agentsim.taz.parkingCostScalingFactor = "double | 1.0"
# options: DEFAULT, HIERARCHICAL, PARALLEL
beam.agentsim.taz.parkingManager.method = "String | DEFAULT"
beam.agentsim.taz.parkingManager.displayPerformanceTimings = false
beam.agentsim.taz.parkingManager.parallel.numberOfClusters = "int | 8"
#Toll params
beam.agentsim.toll.filePath = ${beam.inputDirectory}"/toll-prices.csv"
# Ride Hailing Params: Options are ALL, MASS, or the individual modes comma separate, e.g. BUS,TRAM
beam.agentsim.agents.rideHailTransit.modesToConsider = "MASS"
# Ride Hailing Params

beam.agentsim.agents.rideHail.managers = [{
  initialization.initType = "PROCEDURAL" # Other possible values - FILE
  initialization.filePath = ""
  initialization.parking.filePath = ""
  defaultBaseCost = 1.8
  defaultCostPerMile = 0.91
  defaultCostPerMinute = 0.28
  pooledBaseCost = 1.89
  pooledCostPerMile = 1.11
  pooledCostPerMinute = 0.07
  initialization.procedural.vehicleTypeId = "Car"
  initialization.procedural.vehicleTypePrefix = "RH"
  initialization.procedural.fractionOfInitialVehicleFleet = "double | 0.1"
  initialization.procedural.initialLocation.name = "HOME"
  initialization.procedural.initialLocation.home.radiusInMeters = "double | 10000"
  rideHailManager.radiusInMeters = "double | 5000"
  allocationManager.maxWaitingTimeInSec = "int | 900"
  allocationManager.maxExcessRideTime = "double | 0.5" # up to +50%
  allocationManager.name = "DEFAULT_MANAGER"
  allocationManager.requestBufferTimeoutInSeconds = "int | 0"
  name = "GlobalRHM"
  # ASYNC_GREEDY_VEHICLE_CENTRIC_MATCHING, ALONSO_MORA_MATCHING_WITH_ASYNC_GREEDY_ASSIGNMENT, ALONSO_MORA_MATCHING_WITH_MIP_ASSIGNMENT
  allocationManager.matchingAlgorithm = "ALONSO_MORA_MATCHING_WITH_ASYNC_GREEDY_ASSIGNMENT"
  # ALONSO MORA
  allocationManager.alonsoMora.maxRequestsPerVehicle = "int | 5"
  # Reposition
  allocationManager.pooledRideHailIntervalAsMultipleOfSoloRideHail = "int | 1"
  # SurgePricing parameters
  surgePricing.surgeLevelAdaptionStep = "double | 0.1"
  surgePricing.minimumSurgeLevel = "double | 0.1"
  surgePricing.priceAdjustmentStrategy = "KEEP_PRICE_LEVEL_FIXED_AT_ONE"
  surgePricing.numberOfCategories = "int | 6"

  repositioningManager.name = "DEFAULT_REPOSITIONING_MANAGER"
  repositioningManager.timeout = "int | 0"
  # Larger value increase probability of the ride-hail vehicle to reposition
  repositioningManager.demandFollowingRepositioningManager.sensitivityOfRepositioningToDemand = "double | 1"
  repositioningManager.demandFollowingRepositioningManager.sensitivityOfRepositioningToDemandForCAVs = "double | 1"
  repositioningManager.demandFollowingRepositioningManager.numberOfClustersForDemand = "int | 30"
  repositioningManager.demandFollowingRepositioningManager.fractionOfClosestClustersToConsider = "double | 0.2"
  repositioningManager.demandFollowingRepositioningManager.horizon = "int | 1200"
  # inverse Square Distance Repositioning Factor
  repositioningManager.inverseSquareDistanceRepositioningFactor.sensitivityOfRepositioningToDemand = "double | 0.4"
  repositioningManager.inverseSquareDistanceRepositioningFactor.sensitivityOfRepositioningToDistance = "double | 0.9"
  repositioningManager.inverseSquareDistanceRepositioningFactor.predictionHorizon = "int | 3600"
  # reposition Low Waiting Times
  allocationManager.repositionLowWaitingTimes.repositionCircleRadiusInMeters = "double | 3000"
  allocationManager.repositionLowWaitingTimes.minimumNumberOfIdlingVehiclesThresholdForRepositioning = "int | 1"
  allocationManager.repositionLowWaitingTimes.percentageOfVehiclesToReposition = "double | 0.01"
  allocationManager.repositionLowWaitingTimes.timeWindowSizeInSecForDecidingAboutRepositioning = "double | 1200"
  allocationManager.repositionLowWaitingTimes.allowIncreasingRadiusIfDemandInRadiusLow = true
  allocationManager.repositionLowWaitingTimes.minDemandPercentageInRadius = "double | 0.1"
  allocationManager.repositionLowWaitingTimes.repositioningMethod = "TOP_SCORES"
  allocationManager.repositionLowWaitingTimes.keepMaxTopNScores = "int | 1"
  allocationManager.repositionLowWaitingTimes.minScoreThresholdForRepositioning = "double | 0.1"
  allocationManager.repositionLowWaitingTimes.distanceWeight = "double | 0.01"
  allocationManager.repositionLowWaitingTimes.waitingTimeWeight = "double | 4.0"
  allocationManager.repositionLowWaitingTimes.demandWeight = "double | 4.0"
  allocationManager.repositionLowWaitingTimes.produceDebugImages = true
}]

beam.agentsim.agents.rideHail.linkFleetStateAcrossIterations = "boolean | false"

beam.agentsim.agents.rideHail.cav.valueOfTime = 1.00
# when range below refuelRequiredThresholdInMeters, EV Ride Hail CAVs will charge
# when range above noRefuelThresholdInMeters, EV Ride Hail CAVs will not charge
# (between these params probability of charging is linear interpolation from 0% to 100%)
beam.agentsim.agents.rideHail.human.refuelRequiredThresholdInMeters = 32180.0 # 20 miles
beam.agentsim.agents.rideHail.human.noRefuelThresholdInMeters = 128720.0 # 80 miles
beam.agentsim.agents.rideHail.cav.refuelRequiredThresholdInMeters = 16090.0 # 10 miles
beam.agentsim.agents.rideHail.cav.noRefuelThresholdInMeters = 96540.0 # 60 miles
beam.agentsim.agents.rideHail.rangeBufferForDispatchInMeters = 10000 # do not dispatch vehicles below this range to ensure enough available to get to charger

beam.agentsim.agents.rideHail.charging.multinomialLogit.params.drivingTimeMultiplier = "double | -0.01666667" // one minute of driving is one util
beam.agentsim.agents.rideHail.charging.multinomialLogit.params.queueingTimeMultiplier = "double | -0.01666667" // one minute of queueing is one util
beam.agentsim.agents.rideHail.charging.multinomialLogit.params.chargingTimeMultiplier = "double | -0.01666667" // one minute of charging is one util
beam.agentsim.agents.rideHail.charging.multinomialLogit.params.insufficientRangeMultiplier = "double | -60.0" // indicator variable so straight 60 minute penalty if out of range

beam.agentsim.agents.freight {
  enabled = false
  plansFilePath = ${beam.inputDirectory}"/freight/payload-plans.csv"
  toursFilePath = ${beam.inputDirectory}"/freight/freight-tours.csv"
  carriersFilePath = ${beam.inputDirectory}"/freight/freight-carriers.csv"
  reader = "Generic"
  isWgs = "boolean | false"
  generateFixedActivitiesDurations = "boolean | false"
  name = "Freight"
  nonHGVLinkWeightMultiplier = "double | 2.0"
  tourSampleSizeAsFractionOfTotal = "double | 1.0" # value should be within [0,1]
  #@optional
  carrierParkingFilePath = string
  #@optional
  vehicleTypesFilePath = string
  replanning {
    disableAfterIteration = -1
    #8 AM, required for wholeFleet strategy. The vehicle departure times are distributed in time interval ±1 hour
    departureTime = 28800
    #Possible options: singleTour (when each freight tour is rearranged) | wholeFleet
    strategy = "singleTour"
  }
}

#@optional
beam.agentsim.agents.activities.activityTypeToFixedDurationMap = [string]

beam.agentsim.agents.plans.inputPlansFilePath = ${beam.inputDirectory}"/population.xml.gz"
beam.agentsim.agents.plans.inputPersonAttributesFilePath = ${beam.inputDirectory}"/populationAttributes.xml.gz"
# fraction of input plans (taken from the beam.input.lastBaseOutputDir) to be merged into the latest output plans
beam.agentsim.agents.plans.merge.fraction = "double | 0.0"

beam.agentsim.agents.households.inputFilePath = ${beam.inputDirectory}"/households.xml.gz"
beam.agentsim.agents.households.inputHouseholdAttributesFilePath = ${beam.inputDirectory}"/householdAttributes.xml.gz"

#BeamVehicles Params
beam.agentsim.agents.vehicles.fractionOfInitialVehicleFleet = "double | 1.0"
beam.agentsim.agents.vehicles.vehicleAdjustmentMethod = "UNIFORM"
beam.agentsim.agents.vehicles.downsamplingMethod = "SECONDARY_VEHICLES_FIRST"
beam.agentsim.agents.vehicles.fractionOfPeopleWithBicycle = "double | 1.0"
beam.agentsim.agents.vehicles.linkToGradePercentFilePath = ""
beam.agentsim.agents.vehicles.fuelTypesFilePath = ${beam.inputDirectory}"/beamFuelTypes.csv"
beam.agentsim.agents.vehicles.vehicleTypesFilePath = ${beam.inputDirectory}"/vehicleTypes.csv"
beam.agentsim.agents.vehicles.vehiclesFilePath = ${beam.inputDirectory}"/vehicles.csv"
beam.agentsim.agents.vehicles.meanPrivateVehicleStartingSOC = "double | 1.0"
beam.agentsim.agents.vehicles.linkSocAcrossIterations = "boolean | false"
beam.agentsim.agents.vehicles.meanRidehailVehicleStartingSOC = "double | 1.0"
beam.agentsim.agents.vehicles.transitVehicleTypesByRouteFile = ""
beam.agentsim.agents.vehicles.generateEmergencyHouseholdVehicleWhenPlansRequireIt = "boolean | false"
beam.agentsim.agents.vehicles.replanOnTheFlyWhenHouseholdVehiclesAreNotAvailable = "boolean | false"
beam.agentsim.agents.vehicles.enroute.refuelRequiredThresholdOffsetInMeters = 0.0 # 0 miles
beam.agentsim.agents.vehicles.enroute.noRefuelThresholdOffsetInMeters = 32186.9 # 20 miles
beam.agentsim.agents.vehicles.enroute.noRefuelAtRemainingDistanceThresholdInMeters = 500 # 500 meters
beam.agentsim.agents.vehicles.enroute.remainingDistanceWrtBatteryCapacityThreshold = 2 # this represents +/- the number of times an agent will enroute when ranger is x times lower than the remaining distance
beam.agentsim.agents.vehicles.destination.refuelRequiredThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.noRefuelThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.home.refuelRequiredThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.home.noRefuelThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.work.refuelRequiredThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.work.noRefuelThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.secondary.refuelRequiredThresholdInMeters = 482803 # 300 miles
beam.agentsim.agents.vehicles.destination.secondary.noRefuelThresholdInMeters = 482803 # 300 miles
# these must be one of the shared vehicle types
beam.agentsim.agents.vehicles.dummySharedCar.vehicleTypeId = "sharedVehicle-sharedCar"
beam.agentsim.agents.vehicles.dummySharedBike.vehicleTypeId = "sharedVehicle-sharedBike"
beam.agentsim.agents.vehicles.sharedFleets = [
  {
    name = "my-fixed-non-reserving-fleet"
    managerType = "fixed-non-reserving"
    parkingFilePath = ""
    #@optional
    fixed-non-reserving {
      vehicleTypeId = "String | sharedVehicle-sharedCar",
      maxWalkingDistance = "int | 500"
    }
    #@optional
    inexhaustible-reserving {
      vehicleTypeId = "String | sharedVehicle-sharedCar"
    }
    #@optional
    fixed-non-reserving-fleet-by-taz {
      vehicleTypeId = "String | sharedVehicle-sharedCar",
      vehiclesSharePerTAZFromCSV = "String? |",
      maxWalkingDistance = "int | 500",
      fleetSize = "int | 10"
    }
    #@optional
    reposition {
      name = "my-reposition-algorithm"
      repositionTimeBin = "int | 3600",
      statTimeBin = "int | 300",
      #@optional
      min-availability-undersupply-algorithm {
        matchLimit = "int | 99999"
      }
    }
  }
]


beam.agentsim.chargingNetworkManager {
  timeStepInSeconds = "int | 300"
  # Overnight charging is still a work in progress and might produce unexpected results
  overnightChargingEnabled = "boolean | false"
  chargingPointCountScalingFactor = "double | 1.0"
  chargingPointCostScalingFactor = "double | 1.0"
  chargingPointFilePath = ""
  scaleUp {
    enabled = "boolean | false"
    expansionFactor = "double | 1.0"
    activitiesLocationFilePath = ""
  }
  #@optional
  sitePowerManagerController {
    connect = "boolean | false"
    expectFeedback = "boolean | true"
    numberOfFederates = "int | 1"
    brokerAddress = "String | tcp://127.0.0.1"
    coreType = "String | zmq"
    timeDeltaProperty = "double | 1.0"
    intLogLevel = "int | 1"
    beamFederatePrefix = "String | BEAM_FED"
    beamFederatePublication = "String | CHARGING_VEHICLES"
    spmFederatePrefix = "String | SPM_FED_TAZ"
    spmFederateSubscription = "String | CHARGING_COMMANDS"
    bufferSize = "Int | 10000000"
  }
  #@optional
  powerManagerController {
    connect = "boolean | false"
    feedbackEnabled = "boolean | true"
    brokerAddress = "String | tcp://127.0.0.1"
    coreType = "String | zmq"
    timeDeltaProperty = "double | 1.0"
    intLogLevel = "int | 1"
    beamFederateName = "String | BEAM_FED"
    beamFederatePublication = "String | LOAD_DEMAND"
    pmcFederateName = "String | GRID_FED"
    pmcFederateSubscription = "String | POWER_LIMITS"
    bufferSize = "Int | 10000000"
  }
}

beam.agentsim.agents.population.useVehicleSampling = "boolean | false"
beam.agentsim.agents.population.industryRemovalProbabilty.enabled = "boolean | false"
beam.agentsim.agents.population.industryRemovalProbabilty.inputFilePath = ""
# options: RemovePersonFromScenario, KeepPersonButRemoveAllActivities
beam.agentsim.agents.population.industryRemovalProbabilty.removalStrategy = "String | RemovePersonFromScenario"

beam.exchange {
  scenario {# source for now can be "Beam" or "UrbanSim"
    source = "Beam"
    # Input file format for scenario loader can be "xml", "csv" or "parquet"
    fileFormat = "xml"
    folder = ""
    # Allows to match urbansim modes to beam modes
    #@optional
    modeMap = [
      "BIKE           -> bike",
      "DRIVEALONEFREE -> car",
      "DRIVEALONEPAY  -> car",
      "DRIVE_COM      -> drive_transit",
      "DRIVE_EXP      -> drive_transit",
      "DRIVE_HVY      -> drive_transit",
      "DRIVE_LOC      -> drive_transit",
      "DRIVE_LRF      -> drive_transit",
      "SHARED2FREE    -> car",
      "SHARED2PAY     -> car",
      "SHARED3FREE    -> car",
      "SHARED3PAY     -> car",
      "TAXI           -> ride_hail",
      "TNC_SHARED     -> ride_hail",
      "TNC_SINGLE     -> ride_hail",
      "WALK           -> walk",
      "WALK_COM       -> walk_transit",
      "WALK_EXP       -> walk_transit",
      "WALK_HVY       -> walk_transit",
      "WALK_LOC       -> walk_transit",
      "WALK_LRF       -> walk_transit",
    ]
    convertWgs2Utm = "boolean | false"
    urbansim.activitySimEnabled = "boolean | false"
    urbansim.scenarioLoadingTimeoutSeconds = "int | 3000"
  }
  output {
    activitySimSkimsEnabled = "boolean | false"
    sendNonChosenTripsToSkimmer = "boolean | true"
    # geo level different than TAZ (in beam taz-centers format)
    #@optional
    geo.filePath = string
  }
}

beam.agentsim.agents.rideHail.iterationStats.timeBinSizeInSec = "double | 3600.0"
# SurgePricing parameters
beam.agentsim.agents.rideHail.surgePricing.surgeLevelAdaptionStep = "double | 0.1"
beam.agentsim.agents.rideHail.surgePricing.minimumSurgeLevel = "double | 0.1"
beam.agentsim.agents.rideHail.surgePricing.priceAdjustmentStrategy = "KEEP_PRICE_LEVEL_FIXED_AT_ONE"
beam.agentsim.agents.rideHail.surgePricing.numberOfCategories = "int | 6"
# Scaling and Tuning Params
beam.agentsim.tuning.fuelCapacityInJoules = "double | 86400000"
beam.agentsim.tuning.transitCapacity = "Double?"
beam.agentsim.tuning.transitPrice = "double | 1.0"
beam.agentsim.tuning.tollPrice = "double | 1.0"
beam.agentsim.tuning.rideHailPrice = "double | 1.0"
# Population Adjustmnet
beam.agentsim.populationAdjustment = "DEFAULT_ADJUSTMENT"
# Transit Scenarios
beam.agentsim.scenarios.frequencyAdjustmentFile = ${beam.inputDirectory}"/r5/FrequencyAdjustment.csv"
# PhysSim Scaling Params
beam.physsim.flowCapacityFactor = "double | 1.0"
beam.physsim.storageCapacityFactor = "double | 1.0"
beam.physsim.speedScalingFactor = "double | 1.0"
beam.physsim.maxLinkLengthToApplySpeedScalingFactor = "double | 50.0"
beam.physsim.linkStatsWriteInterval = "int | 1"
beam.physsim.linkStatsBinSize = "int | 3600"
beam.physsim.ptSampleSize = "double | 1.0"
beam.physsim.eventsForFullVersionOfVia = true
beam.physsim.eventsSampling = "double | 1.0"
beam.physsim.initializeRouterWithFreeFlowTimes = true
beam.physsim.quick_fix_minCarSpeedInMetersPerSecond = "double | 0.5"
beam.physsim.inputNetworkFilePath = ${beam.routing.r5.directory}"/physsim-network.xml"
beam.physsim.events.fileOutputFormats = "csv" # valid options: xml(.gz) , csv(.gz), none - DEFAULT: csv.gz
beam.physsim.events.eventsToWrite = "ActivityEndEvent,ActivityStartEvent,LinkEnterEvent,LinkLeaveEvent,PersonArrivalEvent,PersonDepartureEvent,VehicleEntersTrafficEvent,VehicleLeavesTrafficEvent"

# The `duplicatePTE` group of configs allows to increase physSim population without increasing agentSim population.
# The idea behind that is the following - bigger physSim population allows to use higher values of flowCapacityFactor
# thus reducing the rounding error for links capacity.
# This should allow better speed calibration without too high agentSim population.
beam.physsim.duplicatePTE.fractionOfEventsToDuplicate = "double | 0.0"
beam.physsim.duplicatePTE.departureTimeShiftMin = "int | -600"
beam.physsim.duplicatePTE.departureTimeShiftMax = "int | 600"

beam.physsim.skipPhysSim = false
# values: JDEQSim, BPRSim, PARBPRSim, CCHRoutingAssignment
beam.physsim.name = "JDEQSim"
# values: Auto, Sequential, Parallel
beam.physsim.eventManager.type = "Auto"
# number of threads for parallel event manager,
# 1 thread usually shows the best performance (async event handling)
beam.physsim.eventManager.numberOfThreads = "int | 1"

beam.physsim.pickUpDropOffAnalysis.enabled = "boolean | false"
beam.physsim.pickUpDropOffAnalysis.secondsFromPickUpPropOffToAffectTravelTime = "int | 600"
beam.physsim.pickUpDropOffAnalysis.additionalTravelTimeMultiplier = "double | 1.0"

# JDEQSim

beam.physsim.jdeqsim.agentSimPhysSimInterfaceDebugger.enabled = false
beam.physsim.jdeqsim.cacc.enabled = false
beam.physsim.jdeqsim.cacc.minRoadCapacity = "int | 2000"
beam.physsim.jdeqsim.cacc.minSpeedMetersPerSec = "int | 20"
beam.physsim.jdeqsim.cacc.speedAdjustmentFactor = "double | 1.0"
beam.physsim.jdeqsim.cacc.capacityPlansWriteInterval = 0
beam.physsim.jdeqsim.cacc.adjustedMinimumRoadSpeedInMetersPerSecond = "double | 1.3"

# values: BPR, FREE_FLOW
beam.physsim.bprsim.travelTimeFunction = "BPR"
beam.physsim.bprsim.minFlowToUseBPRFunction = "int | 0"
beam.physsim.bprsim.inFlowAggregationTimeWindowInSeconds = "int | 900"
beam.physsim.parbprsim.numberOfClusters = "int | 8"
# sync of bpr sim clusters every syncInterval seconds
beam.physsim.parbprsim.syncInterval = "int | 60"

# CCHRoutingAssignment

#Used to calculate ods number multiplier with following formula:
#1 / agentSampleSizeAsFractionOfPopulation * congestionFactor
beam.physsim.cchRoutingAssignment.congestionFactor = "double | 1.0"

beam.physsim.overwriteLinkParamPath = ""

# Possible type is one of: normal, experiment_2.0, experiment_2.1, experiment_3.0, experiment_4.0, experiment_5.0, experiment_5.1, experiment_5.2, consecutive_increase_of_population
beam.physsim.relaxation.type = "normal"
beam.physsim.relaxation.experiment2_0.internalNumberOfIterations = "int | 15"
beam.physsim.relaxation.experiment2_0.fractionOfPopulationToReroute = "double | 0.1"
beam.physsim.relaxation.experiment2_0.clearRoutesEveryIteration = "boolean | true"
beam.physsim.relaxation.experiment2_0.clearModesEveryIteration = "boolean | true"

beam.physsim.relaxation.experiment2_1.internalNumberOfIterations = "int | 15"
beam.physsim.relaxation.experiment2_1.fractionOfPopulationToReroute = "double | 0.1"
beam.physsim.relaxation.experiment2_1.clearRoutesEveryIteration = "boolean | true"
beam.physsim.relaxation.experiment2_1.clearModesEveryIteration = "boolean | true"

beam.physsim.relaxation.experiment3_0.internalNumberOfIterations = "int | 15"
beam.physsim.relaxation.experiment3_0.fractionOfPopulationToReroute = "double | 0.1"

#@optional
beam.physsim.relaxation.experiment4_0.percentToSimulate = [double]
#@optional
beam.physsim.relaxation.experiment5_0.percentToSimulate = [double]
#@optional
beam.physsim.relaxation.experiment5_1.percentToSimulate = [double]
#@optional
beam.physsim.relaxation.experiment5_2.percentToSimulate = [double]

beam.physsim.network.overwriteRoadTypeProperties {
  enabled = false
  motorway {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  motorwayLink {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  primary {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  primaryLink {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  trunk {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  trunkLink {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  secondary {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  secondaryLink {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  tertiary {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  tertiaryLink {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  minor {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  residential {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  livingStreet {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
  unclassified {
    speed = "double?"
    capacity = "int?"
    lanes = "int?"
    alpha = "double?"
    beta = "double?"
  }
}

beam.physsim.network.maxSpeedInference {
  enabled = "boolean | false"
  # Possible types of inference: MEAN, MEDIAN
  type = "String | MEAN"
}

# For a small test OSM map (10-20 nodes) it might be possible that R5 TransportNetwork would incorrectly consider
# all nodes to be an island and will remove it. Set this to `false` to override that.
beam.physsim.network.removeIslands = "boolean | true"

# Replanning
beam.replanning.maxAgentPlanMemorySize = "int | 5"
beam.replanning.Module_1 = "SelectExpBeta"
beam.replanning.ModuleProbability_1 = 0.8
beam.replanning.Module_2 = "ClearRoutes"
beam.replanning.ModuleProbability_2 = 0.1
beam.replanning.Module_3 = "ClearModes"
beam.replanning.ModuleProbability_3 = 0.1
beam.replanning.Module_4 = "TimeMutator"
beam.replanning.ModuleProbability_4 = 0.0
beam.replanning.fractionOfIterationsToDisableInnovation = "double | Double.PositiveInfinity"
#@optional
beam.replanning.clearModes.modes = [string] | []
beam.replanning.clearModes.iteration = "int | 0"
#clear mode strategy options: AtBeginningOfIteration | AtBeginningAndAllSubsequentIterations
beam.replanning.clearModes.strategy = "AtBeginningOfIteration"

#skims
beam.router.skim = {
  keepKLatestSkims = "int | 1"
  writeSkimsInterval = "int | 0"
  writeAggregatedSkimsInterval = "int | 0"
  activity-sim-skimmer {
    name = "activity-sim-skimmer"
    fileBaseName = "String | activitySimODSkims"
  }
  drive-time-skimmer {
    name = "drive-time-skimmer"
    fileBaseName = "String | skimsTravelTimeObservedVsSimulated"
  }
  origin-destination-skimmer {
    name = "od-skimmer"
    fileBaseName = "String | skimsOD"
    writeAllModeSkimsForPeakNonPeakPeriodsInterval = "int | 0"
    writeFullSkimsInterval = "int | 0"
    poolingTravelTimeOveheadFactor = "double | 1.21"
  }
  taz-skimmer {
    name = "taz-skimmer"
    fileBaseName = "String | skimsTAZ"
    geoHierarchy = "String | TAZ" # TAZ or H3
  }
  transit-crowding-skimmer {
    name = "transit-crowding-skimmer"
    fileBaseName = "String | skimsTransitCrowding"
  }
}

#h3taz
beam.agentsim.h3taz = {
  lowerBoundResolution = "int | 6"
  upperBoundResolution = "int | 9"
}

##################################################################
# Warm Mode
##################################################################
# valid options: 
# * disabled
# * full
# * linkStatsOnly (only link stats is loaded (all the other data is got from the input directory))
# * linkStatsFromLastRun (only link stats is loaded from beam.input.lastBaseOutputDir directory)
beam.warmStart.type = "disabled"
beam.warmStart.samplePopulationIntegerFlag = 0 # Int chosen instead of Boolean, as passthrough coverts Boolean to Int
#PATH can be a directory or zip archive of the output directory (e.g. like what get's stored on S3), including a URL to an S3 output.
beam.warmStart.path = ""

#creates warmstart_data.zip that can be used for warmstart
beam.warmStart.prepareData = false
#@optional
beam.warmStart.skimsFilePaths = [  # Filled by warmstart
  {
    skimType = "String"
    skimsFilePath = ""
  }
]

##################################################################
# Debugging
##################################################################
beam.debug {
  debugEnabled = false
  agentTripScoresInterval = 0

  triggerMeasurer {
    enabled = false
    writeStuckAgentDetectionConfig = true
  }

  stuckAgentDetection {
    enabled = false
    checkIntervalMs = "duration:ms | 200ms"
    defaultTimeoutMs = "duration:ms | 60s"
    overallSimulationTimeoutMs = "duration:ms | 100s"
    checkMaxNumberOfMessagesEnabled = true
    thresholds = [
      # Possible values (with deviations from default):
      # triggerType = "beam.agentsim.agents.PersonAgent$ActivityStartTrigger" && markAsStuckAfterMs = 20s
      # triggerType = "beam.agentsim.agents.PersonAgent$ActivityEndTrigger" && markAsStuckAfterMs = 60s
      # triggerType = "beam.agentsim.agents.PersonAgent$PersonDepartureTrigger"
      # triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$StartLegTrigger" && markAsStuckAfterMs = 18s
      # triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$EndLegTrigger" && markAsStuckAfterMs = 60s
      # triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$AlightVehicleTrigger" && markAsStuckAfterMs = 21s
      # triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$BoardVehicleTrigger" && markAsStuckAfterMs = 21s
      # triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$StartRefuelSessionTrigger" && markAsStuckAfterMs = 21s
      # riggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$EndRefuelSessionTrigger" && markAsStuckAfterMs = 21s
      # triggerType = "beam.agentsim.agents.InitializeTrigger"
      # triggerType = "beam.agentsim.agents.ridehail.RideHailManager$BufferedRideHailRequestsTimeout"
      # triggerType = "beam.agentsim.agents.ridehail.RideHailManager$RideHailAllocationManagerTimeout" && markAsStuckAfterMs = 40s
      {
        triggerType = "beam.agentsim.agents.PersonAgent$ActivityStartTrigger"
        markAsStuckAfterMs = "duration:ms | 20s"
        actorTypeToMaxNumberOfMessages {
          population = "int?"
          transitDriverAgent = "int?"
          rideHailAgent = "int?"
          rideHailManager = "int?"
        }
      }
    ]
  }

  debugActorTimerIntervalInSec = "int | 0"
  actor.logDepth = "int | 0"
  memoryConsumptionDisplayTimeoutInSec = "int | 0"
  clearRoutedOutstandingWorkEnabled = "boolean | false"
  secondsToWaitToClearRoutedOutstandingWork = 60

  vmInformation.createGCClassHistogram = "boolean | false"
  # it implies vmInformation.createGCClassHistogram = true
  vmInformation.writeHeapDump = "boolean | false"
  writeModeChoiceAlternatives = "boolean | false"

  writeRealizedModeChoiceFile = "boolean | false"
  messageLogging = "boolean | false"
  # the max of the next 2 values is taken for the initialization step
  maxSimulationStepTimeBeforeConsideredStuckMin = "int | 60"
  maxSimulationStepTimeBeforeConsideredStuckAtInitializationMin = "int | 600"
}

beam.logger.keepConsoleAppenderOn = "boolean | true"

##################################################################
# Metrics
##################################################################
beam.metrics.level = "verbose"

##################################################################
# Calibration
##################################################################
beam.calibration.objectiveFunction = "ModeChoiceObjectiveFunction"
beam.calibration.meanToCountsWeightRatio = "double | 0.5"
beam.calibration.mode.benchmarkFilePath = ""
beam.calibration.roadNetwork.travelTimes.zoneBoundariesFilePath = ""
beam.calibration.roadNetwork.travelTimes.zoneODTravelTimesFilePath = ""

beam.calibration.google.travelTimes.enable = "boolean | false"
beam.calibration.google.travelTimes.numDataPointsOver24Hours = "int | 100"
beam.calibration.google.travelTimes.minDistanceInMeters = "double | 5000"
beam.calibration.google.travelTimes.iterationInterval = "int | 5"
beam.calibration.google.travelTimes.tolls = "boolean | true"
beam.calibration.google.travelTimes.queryDate = "2020-10-14"
beam.calibration.google.travelTimes.offPeakEnabled = "boolean | false"

beam.calibration.studyArea.enabled = "boolean | false"
beam.calibration.studyArea.lat = "double | 0"
beam.calibration.studyArea.lon = "double | 0"
beam.calibration.studyArea.radius = "double | 0"

##################################################################
# OUTPUTS
##################################################################
# The outputDirectory is the base directory where outputs will be written. The beam.agentsim.simulationName param will
# be used as the name of a sub-directory beneath the baseOutputDirectory for simulation results.
# If addTimestampToOutputDirectory == true, a timestamp will be added, e.g. "beamville_2017-12-18_16-48-57"
beam.outputs.baseOutputDirectory = "output"
#beam.outputs.baseOutputDirectory = ${?BEAM_OUTPUT}
beam.outputs.addTimestampToOutputDirectory = true
beam.outputs.writeGraphs = true
beam.outputs.collectAndCreateBeamAnalysisAndGraphs = "boolean | true" # TODO: when merged upstream, resolve overlap with 'writeGraphs'
beam.outputs.displayPerformanceTimings = false
beam.outputs.generalizedLinkStats.startTime = 25200
beam.outputs.generalizedLinkStats.endTime = 32400

# To keep all logging params in one place, BEAM overrides MATSim params normally in the controller config module
beam.outputs.defaultWriteInterval = 1
beam.outputs.writePlansInterval = "int | 0"
beam.outputs.writeEventsInterval = "int | 1"
beam.outputs.writeAnalysis = "boolean | true"
beam.outputs.writeR5RoutesInterval = "int | 0"
beam.physsim.writeEventsInterval = "int | 0"
beam.physsim.writePlansInterval = "int | 0"
beam.physsim.writeRouteHistoryInterval = "int | 10"
beam.physsim.linkStatsWriteInterval = "int | 0"
beam.outputs.generalizedLinkStatsInterval = 0

# this will write out plans and throw and exception at the beginning of simulation
beam.output.writePlansAndStopSimulation = "boolean | false"

# The remaining params customize how events are written to output files
beam.outputs.events.fileOutputFormats = "csv" # valid options: xml(.gz) , csv(.gz), none - DEFAULT: csv.gz

# Events Writing Logging Levels:
# Any event types not explicitly listed in overrideWritingLevels take on defaultWritingLevel
beam.outputs.events.eventsToWrite = "ActivityEndEvent,ActivityStartEvent,PersonEntersVehicleEvent,PersonLeavesVehicleEvent,ModeChoiceEvent,PathTraversalEvent,ReserveRideHailEvent,ReplanningEvent,RefuelSessionEvent,ChargingPlugInEvent,ChargingPlugOutEvent,ParkingEvent,LeavingParkingEvent"
beam.outputs.stats.binSize = 3600

#Delete MATSim files from root folder:
#beam.outputs.matsim.deleteRootFolderFiles="output_config.xml,output_counts.xml.gz,output_facilities.xml.gz,output_householdAttributes.xml.gz,output_households.xml.gz,output_lanes.xml.gz,output_network.xml.gz,output_experienced_plans.xml.gz,output_personAttributes.xml.gz,output_plans.xml.gz,output_vehicles.xml.gz,scorestats.txt,scorestats.png,traveldistancestats.txt,traveldistancestats.png,tmp"
beam.outputs.matsim.deleteRootFolderFiles = ""

#Delete MATSim files from ITERS folder:
#beam.outputs.matsim.deleteITERSFolderFiles="experienced_plans.xml.gz,legHistogram.txt,legHistogram_all.png,legHistogram_bike.png,legHistogram_cav.png,legHistogram_ride_hail.png,legHistogram_walk.png,legHistogram_car.png,legHistogram_walk_transit.png,tripdurations.txt"
beam.outputs.matsim.deleteITERSFolderFiles = ""
##################################################################
# SPATIAL
##################################################################
beam.spatial = {
  localCRS = "epsg:32631"  # what crs to use for distance calculations, must be in units of meters
  boundingBoxBuffer = 5000 # meters of buffer around network for defining extend of spatial indices
}

##################################################################
# MATSim Conversion
##################################################################
matsim.conversion {
  scenarioDirectory = "/path/to/scenario/directory"
  populationFile = "Siouxfalls_population.xml"
  matsimNetworkFile = "Siouxfalls_network_PT.xml"
  generateVehicles = true
  vehiclesFile = "Siouxfalls_vehicles.xml"
  defaultHouseholdIncome {
    currency = "usd"
    period = "year"
    value = 50000
  }
  osmFile = "south-dakota-latest.osm.pbf"
  shapeConfig {
    shapeFile = "tz46_d00.shp"
    tazIdFieldName = "TZ46_D00_I"
  }
}

##################################################################
# BEAM ROUTING
##################################################################
# values: R5, staticGH, quasiDynamicGH, nativeCCH (Linux Only)
beam.routing.carRouter = "R5"
beam.routing {
  #Base local date in ISO 8061 YYYY-MM-DDTHH:MM:SS+HH:MM
  baseDate = "2016-10-17T00:00:00-07:00"
  transitOnStreetNetwork = true # PathTraversalEvents for transit vehicles
  r5 {
    directory = ${beam.inputDirectory}"/r5"
    #allows to use the second r5 router in order to increase returned options
    directory2 = "String? |"
    # Departure window in min
    departureWindow = "double | 15.0"
    numberOfSamples = "int | 1"
    osmMapdbFile = ${beam.routing.r5.directory}"/osm.mapdb"
    mNetBuilder.fromCRS = "EPSG:4326"   # WGS84
    mNetBuilder.toCRS = "EPSG:26910"    # UTM10N
    travelTimeNoiseFraction = "double | 0.0"
    maxDistanceLimitByModeInMeters {
      bike = "int | 40000"
    }
    bikeLaneScaleFactor = "double | 1.0"
    bikeLaneLinkIdsFilePath = ""
    linkRadiusMeters = "double | 10000.0"
    # Determines the way R5 chooses to keep alternative routes listed.
    # OPTIMAL - keeps a route only if there is no other route with the same access and egress modes
    # that is both cheaper and faster;
    # SUBOPTIMAL - keeps all possible routes that are a configurable amount of time slower than
    # the fastest observed route.
    transitAlternativeList = "OPTIMAL"
    # Used only for transitAlternativeList = "SUBOPTIMAL", configures the amount of time other possible
    # routes can be slower than the fastest one and be kept in the alternative routes list.
    # If the route has the same access mode as the fastest, this parameter determines how many minutes
    # a route can be slower to be kept;
    # if the route has a different access mode to the fastest, the actual amount of minutes used to decide
    # if it will be kept is 5 times this parameter.
    suboptimalMinutes = "int | 0"
    # HOW LONG DOES IT TAKE YOU TO PARK YOUR VEHICLE AT THE STATION
    accessBufferTimeSeconds {
      bike = "int | 60"
      bike_rent = "int | 180"
      walk = "int | 0"
      car = "int | 300"
      ride_hail = "int | 0"
    }
  }
  gh {
    useAlternativeRoutes = "boolean | false"
  }
  startingIterationForTravelTimesMSA = "int | 0"
  overrideNetworkTravelTimesUsingSkims = "boolean | false"

  # Set a lower bound on travel times that can possibly be used to override the network-based
  # travel time in the route.This is used to prevent unrealistically fast trips or negative
  # duration trips.
  minimumPossibleSkimBasedTravelTimeInS = "int | 60"
  skimTravelTimesScalingFactor = "double | 0.0"
  writeRoutingStatistic = "boolean | false"
}

##################################################################
# Counts
##################################################################
beam.calibration.counts {
  countsScaleFactor = 10
  writeCountsInterval = 1
  averageCountsOverIterations = 1
  inputCountsFile = ""
}

##################################################################
# MATSim Modules
##################################################################

matsim.modules {
  global {
    randomSeed = 4711
    coordinateSystem = "Atlantis"
  }
  counts {
    countsScaleFactor = 10.355
    averageCountsOverIterations = 0
    writeCountsInterval = 0
    inputCountsFile = ""
    outputformat = "all"
  }
  network {
    inputNetworkFile = ${beam.routing.r5.directory}"/physsim-network.xml"
  }
  plans {
    inputPlansFile = ${beam.inputDirectory}"/population.xml"
    inputPersonAttributesFile = ${beam.inputDirectory}"/populationAttributes.xml"
  }
  households {
    inputFile = ${beam.inputDirectory}"/households.xml"
    inputHouseholdAttributesFile = ${beam.inputDirectory}"/householdAttributes.xml"
  }
  vehicles {
    vehiclesFile = ""
  }
  strategy {
    maxAgentPlanMemorySize = 5
    planSelectorForRemoval = "WorstPlanForRemovalSelector"

    ModuleProbability_1 = 0.0
    Module_1 = ""

    ModuleProbability_2 = 0.0
    Module_2 = ""

    ModuleProbability_3 = 0.0
    Module_3 = ""

    ModuleProbability_4 = 0.0
    Module_4 = ""

    fractionOfIterationsToDisableInnovation = 999999

    parameterset = [
      {
        type = "strategysettings"
        disableAfterIteration = -1
        strategyName = ""
        weight = 0.0
      }
    ]
  }
  parallelEventHandling {
    #Estimated number of events during mobsim run. An optional optimization hint for the framework.
    estimatedNumberOfEvents = 1000000000
    #Number of threads for parallel events handler. 0 or null means the framework decides by itself.
    numberOfThreads = 1
    #If enabled, each event handler is assigned to its own thread. Note that enabling this feature disabled the numberOfThreads option! This feature is still experimental!
    oneThreadPerHandler = false
    # If enabled, it is ensured that all events that are created during a time step of the mobility simulation are processed before the next time step is simulated. E.g. neccessary when within-day replanning is used.
    synchronizeOnSimSteps = false
  }
  controler {
    outputDirectory = ""
    firstIteration = 0
    lastIteration = 0
    eventsFileFormat = "xml"
    mobsim = "metasim"
    overwriteFiles = "overwriteExistingFiles"
  }
  qsim {
    #"start/endTime" of MobSim (00:00:00 == take earliest activity time/ run as long as active vehicles exist) -->
    startTime = "00:00:00"
    endTime = "30:00:00"
    #00:00:00 means NO snapshot writing
    snapshotperiod = "00:00:00"
  }
  transit {
    useTransit = false
    vehiclesFile = ""
    transitModes = "pt"
  }
  changeMode {
    modes = "car,pt"
  }
  planCalcScore {
    writeExperiencedPlans = true
    learningRate = "1.0"
    BrainExpBeta = "2.0"
    lateArrival = "-18"
    earlyDeparture = "-0"
    performing = "6.0"
    traveling = "-6.0"
    waiting = "-0"

    parameterset = [
      # Possible values (with deviations from default):
      # activityType = "Home" && typicalDuration = "01:00:00"
      # activityType = "Work" && typicalDuration = "09:00:00"
      # activityType = "Shopping" && typicalDuration = "09:00:00"
      # activityType = "Social" && typicalDuration = "04:00:00"
      # activityType = "Eatout" && typicalDuration = "02:00:00"
      # activityType = "School" && typicalDuration = "08:00:00"
      # activityType = "Escort" && typicalDuration = "00:30:00"
      # activityType = "University" && typicalDuration = "08:00:00"
      # activityType = "Other" && typicalDuration = "02:00:00"
      {
        type = "activityParams"
        activityType = "Home"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "01:00:00"
        typicalDurationScoreComputation = "uniform"
      }
    ]
  }
  linkStats {
    writeLinkStatsInterval = "int | 10"
    averageLinkStatsOverIterations = "int | 5"
  }
}

beam.sim.metric.collector {
  influxDbSimulationMetricCollector {
    database = "beam"
    connectionString = "http://localhost:8086"
  }
  metrics = "beam-run, beam-iteration"
}

beam.urbansim.fractionOfModesToClear {
  allModes = "double | 0.0"
  car = "double | 0.0"
  bike = "double | 0.0"
  walk = "double | 0.0"
  walk_transit = "double | 0.0"
  drive_transit = "double | 0.0"
}

beam.urbansim.backgroundODSkimsCreator {
  enabled = "boolean | false"
  calculationTimeoutHours = "int | 6"
  modesToBuild = {
    walk = "boolean | true"
    drive = "boolean | true"
    transit = "boolean | true"
  }
  maxTravelDistanceInMeters = {
    bike = "int | 33000"
    walk = "int | 10000"
  }
  #@optional
  peakHours = [double]
  # possible values: r5, r5+gh
  routerType = "string | r5"
  # possible values: taz, h3
  skimsGeoType = "string | h3"
  # possible values: od, activitySim
  skimsKind = "string | od"
  numberOfH3Indexes = "int | 1000"
}

