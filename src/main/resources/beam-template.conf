##################################################################
# EXPERIMENTAL
##################################################################
beam.experimental.optimizer.enabled = "boolean | false"

##################################################################
# EXECUTION
##################################################################
beam.cluster.enabled = "boolean | false"
beam.cluster.clusterType = "String? |"
beam.useLocalWorker = "boolean | true"

##################################################################
# SIMULATION
##################################################################
beam.inputDirectory = "/test/input/beamville"
beam.agentsim.simulationName = "beamville"
beam.agentsim.agentSampleSizeAsFractionOfPopulation = "double | 1.0"
beam.agentsim.thresholdForWalkingInMeters = 100
beam.agentsim.thresholdForMakingParkingChoiceInMeters = 100
beam.agentsim.schedulerParallelismWindow = "int | 30"
beam.agentsim.timeBinSize = "int | 3600"
beam.agentsim.firstIteration = "int | 0"
beam.agentsim.lastIteration = "int | 0"
beam.agentsim.startTime = "00:00:00"
beam.agentsim.endTime = "30:00:00"
beam.agentsim.scheduleMonitorTask.initialDelay = 1
beam.agentsim.scheduleMonitorTask.interval = 30

beam.agentsim.agents.bodyType = "BODY-TYPE-DEFAULT"

# MODE CHOICE OPTIONS:
# ModeChoiceMultinomialLogit ModeChoiceTransitIfAvailable ModeChoiceDriveIfAvailable ModeChoiceRideHailIfAvailable
# ModeChoiceUniformRandom ModeChoiceLCCM
beam.agentsim.agents.modalBehaviors.modeChoiceClass = "ModeChoiceMultinomialLogit"
beam.agentsim.agents.modalBehaviors.maximumNumberOfReplanningAttempts = 3
beam.agentsim.agents.modalBehaviors.defaultValueOfTime = "double | 8.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.transit = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.bike = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.walk = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHail = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHailPooled = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.rideHailTransit = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.waiting = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.CAV = "double | 1.0"
beam.agentsim.agents.modalBehaviors.modeVotMultiplier.drive = "double | 1.0"
beam.agentsim.agents.modalBehaviors.overrideAutomationLevel = "int | 1"
beam.agentsim.agents.modalBehaviors.overrideAutomationForVOTT = "boolean | false"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.poolingMultiplier.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level5 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level4 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.Level3 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.highCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.highTimeSensitivity.lowCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.highCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.highwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lowTimeSensitivity.lowCongestion.nonHighwayFactor.LevelLE2 = "double | 1.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.transfer = "double | -1.4"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.car_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.cav_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.walk_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.drive_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.ride_hail_transit_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.ride_hail_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.ride_hail_pooled_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.walk_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.params.bike_intercept = "double | 0.0"
beam.agentsim.agents.modalBehaviors.mulitnomialLogit.utility_scale_factor = "double | 1.0"
beam.agentsim.agents.modalBehaviors.lccm.filePath = ${beam.inputDirectory}"/lccm-long.csv"
beam.agentsim.agents.modeIncentive.filePath = ""
beam.agentsim.agents.ptFare.filePath = ""
beam.agentsim.agents.parking.mulitnomialLogit.params.rangeAnxietyMultiplier = "double | -0.5"   // fit range anxiety between [-1, 0]
beam.agentsim.agents.parking.mulitnomialLogit.params.distanceMultiplier = "double | -0.086"     // based on 20m walk, VoT = $35/hr should be u=-1.0
beam.agentsim.agents.parking.mulitnomialLogit.params.parkingPriceMultiplier = "double | -0.005" // based on avg. parking prices up to $200!
beam.agentsim.agents.parking.mulitnomialLogit.params.homeActivityPrefersResidentialParkingMultiplier = "double | 1.0" // positive boost of 1.0 if true
beam.agentsim.agents.parking.rangeAnxietyBuffer = "double | 20000.0" // if our remaining range exceeds our remaining tour plus this many meters, then we feel no anxiety; default 20k
beam.agentsim.agents.parking.minSearchRadius = "double | 250.00"  // something small enough that, on average, we see 2 orders of magnitude of samples at most
beam.agentsim.agents.parking.maxSearchRadius = "double | 8046.72" // something large enough that we don't strand our drivers in an oasis

#TAZ params
beam.agentsim.taz.filePath = ${beam.inputDirectory}"/taz-centers.csv"
beam.agentsim.taz.parkingFilePath = ${beam.inputDirectory}"/taz-parking.csv"
beam.agentsim.taz.parkingStallCountScalingFactor = "double | 1.0"
beam.agentsim.taz.parkingCostScalingFactor = "double | 1.0"
#Toll params
beam.agentsim.toll.filePath = ${beam.inputDirectory}"/toll-prices.csv"
# Ride Hailing Params: Options are ALL, MASS, or the individual modes comma separate, e.g. BUS,TRAM
beam.agentsim.agents.rideHailTransit.modesToConsider = "MASS"
# Ride Hailing Params
beam.agentsim.agents.rideHail.initialization.initType = "PROCEDURAL" # Other possible values - FILE
beam.agentsim.agents.rideHail.initialization.filePath = ${beam.inputDirectory}"/ride-hail-fleet.csv"
beam.agentsim.agents.rideHail.initialization.parking.filePath = ${beam.inputDirectory}"/ride-hail-parking.csv"
beam.agentsim.agents.rideHail.defaultBaseCost = 1.8
beam.agentsim.agents.rideHail.defaultCostPerMile = 0.91
beam.agentsim.agents.rideHail.defaultCostPerMinute = 0.28
beam.agentsim.agents.rideHail.pooledBaseCost = 1.89
beam.agentsim.agents.rideHail.pooledCostPerMile = 1.11
beam.agentsim.agents.rideHail.pooledCostPerMinute = 0.07
beam.agentsim.agents.rideHail.initialization.procedural.vehicleTypeId = "Car"
beam.agentsim.agents.rideHail.initialization.procedural.vehicleTypePrefix = "RH"
beam.agentsim.agents.rideHail.initialization.procedural.fractionOfInitialVehicleFleet = "double | 0.1"
beam.agentsim.agents.rideHail.refuelThresholdInMeters = "double | 5000.0"
beam.agentsim.agents.rideHail.refuelLocationType = "AtTAZCenter"
beam.agentsim.agents.rideHail.rideHailManager.radiusInMeters = "double | 5000"
beam.agentsim.agents.rideHail.allocationManager.name = "DEFAULT_MANAGER"
beam.agentsim.agents.rideHail.allocationManager.requestBufferTimeoutInSeconds = "int | 0"

beam.agentsim.agents.rideHail.repositioningManager.name = "DEFAULT_REPOSITIONING_MANAGER"
beam.agentsim.agents.rideHail.repositioningManager.timeout = "int | 0"
# Larger value increase probability of the ride-hail vehicle to reposition
beam.agentsim.agents.rideHail.repositioningManager.demandFollowingRepositioningManager.sensitivityOfRepositioningToDemand = "double | 1"
beam.agentsim.agents.rideHail.repositioningManager.demandFollowingRepositioningManager.sensitivityOfRepositioningToDemandForCAVs = "double | 1"
beam.agentsim.agents.rideHail.repositioningManager.demandFollowingRepositioningManager.numberOfClustersForDemand = "int | 30"
beam.agentsim.agents.rideHail.repositioningManager.demandFollowingRepositioningManager.fractionOfClosestClustersToConsider = "double | 0.2"
beam.agentsim.agents.rideHail.repositioningManager.demandFollowingRepositioningManager.horizon = "int | 1200"

beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.repositionCircleRadiusInMeters = "double | 3000"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.minimumNumberOfIdlingVehiclesThresholdForRepositioning = "int | 1"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.percentageOfVehiclesToReposition = "double | 0.01"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.timeWindowSizeInSecForDecidingAboutRepositioning = "double | 1200"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.allowIncreasingRadiusIfDemandInRadiusLow = true
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.minDemandPercentageInRadius = "double | 0.1"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.repositioningMethod = "TOP_SCORES"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.keepMaxTopNScores = "int | 1"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.minScoreThresholdForRepositioning = "double | 0.1"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.distanceWeight = "double | 0.01"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.waitingTimeWeight = "double | 4.0"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.demandWeight = "double | 4.0"
beam.agentsim.agents.rideHail.allocationManager.repositionLowWaitingTimes.produceDebugImages = true
beam.agentsim.agents.rideHail.allocationManager.alonsoMora.waitingTimeInSec = "int | 360"
beam.agentsim.agents.rideHail.allocationManager.alonsoMora.excessRideTimeAsFraction= "double | 0.2"
beam.agentsim.agents.rideHail.allocationManager.alonsoMora.numRequestsPerVehicle = "int | 5"
beam.agentsim.agents.rideHail.pooledToRegularRideCostRatio = 0.6

# human value of time taken from # https://theicct.org/sites/default/files/publications/Electric_shared_mobility_20190114.pdf
beam.agentsim.agents.rideHail.human.valueOfTime = 22.90
beam.agentsim.agents.rideHail.cav.valueOfTime = 1.00
# when range below refuelRequiredThresholdInMeters, EV Ride Hail CAVs will charge
# when range above noRefuelThresholdInMeters, EV Ride Hail CAVs will not charge
# (between these params probability of charging is linear interpolation from 0% to 100%)
beam.agentsim.agents.rideHail.human.refuelRequiredThresholdInMeters = 32180.0 # 20 miles
beam.agentsim.agents.rideHail.human.noRefuelThresholdInMeters = 128720.0 # 80 miles
beam.agentsim.agents.rideHail.cav.refuelRequiredThresholdInMeters = 16090.0 # 10 miles
beam.agentsim.agents.rideHail.cav.noRefuelThresholdInMeters = 96540.0 # 60 miles
beam.agentsim.agents.rideHail.rangeBufferForDispatchInMeters = 10000 // don't dispatch vehicles below this range to ensure enough available to get to charger

beam.agentsim.agents.plans.inputPlansFilePath = ${beam.inputDirectory}"/population.xml.gz"
beam.agentsim.agents.plans.inputPersonAttributesFilePath = ${beam.inputDirectory}"/populationAttributes.xml.gz"
beam.agentsim.agents.households.inputFilePath = ${beam.inputDirectory}"/households.xml.gz"
beam.agentsim.agents.households.inputHouseholdAttributesFilePath = ${beam.inputDirectory}"/householdAttributes.xml.gz"

#BeamVehicles Params
beam.agentsim.agents.vehicles.fractionOfInitialVehicleFleet = "double | 1.0"
beam.agentsim.agents.vehicles.vehicleAdjustmentMethod = "UNIFORM"
beam.agentsim.agents.vehicles.downsamplingMethod = "SECONDARY_VEHICLES_FIRST"
beam.agentsim.agents.vehicles.linkToGradePercentFilePath = ""
beam.agentsim.agents.vehicles.fuelTypesFilePath = ${beam.inputDirectory}"/beamFuelTypes.csv"
beam.agentsim.agents.vehicles.vehicleTypesFilePath = ${beam.inputDirectory}"/vehicleTypes.csv"
beam.agentsim.agents.vehicles.vehiclesFilePath = ${beam.inputDirectory}"/vehicles.csv"
beam.agentsim.agents.vehicles.meanPrivateVehicleStartingSOC = "double | 1.0"
beam.agentsim.agents.vehicles.meanRidehailVehicleStartingSOC = "double | 1.0"
beam.agentsim.agents.vehicles.transitVehicleTypesByRouteFile = ""
beam.agentsim.agents.vehicles.sharedFleets = [
  {
    name = "my-fixed-non-reserving-fleet"
    managerType = "fixed-non-reserving"
    #@optional
    fixed-non-reserving {
      vehicleTypeId = "String | sharedCar",
      maxWalkingDistance = "int | 500"
    }
    #@optional
    inexhaustible-reserving {
      vehicleTypeId = "sharedCar"
    }
    #@optional
    fixed-non-reserving-fleet-by-taz {
      vehicleTypeId = "String | sharedCar",
      vehiclesSharePerTAZFromCSV = "String? |",
      maxWalkingDistance = "int | 500",
      fleetSize = "int | 10"
    }
    #@optional
    reposition {
      name = "my-reposition-algorithm"
      repositionTimeBin = "int | 3600",
      statTimeBin = "int | 300",
      #@optional
      min-availability-undersupply-algorithm {
        matchLimit = "int | 99999"
      }
    }
  }
]

beam.agentsim.agents.population.useVehicleSampling = "boolean | false"

beam.exchange.scenario {
  # source for now can be "Beam" or "UrbanSim"
  source = "Beam"
  # Input file format for scenario loader can be "xml", "csv" or "parquet"
  fileFormat = "xml"
  folder = ""
  convertWgs2Utm = "boolean | false"
}

beam.agentsim.agents.rideHail.initialization.procedural.initialLocation.name = "HOME"
beam.agentsim.agents.rideHail.initialization.procedural.initialLocation.home.radiusInMeters = "double | 10000"
beam.agentsim.agents.rideHail.iterationStats.timeBinSizeInSec = "double | 3600.0"
# SurgePricing parameters
beam.agentsim.agents.rideHail.surgePricing.surgeLevelAdaptionStep = "double | 0.1"
beam.agentsim.agents.rideHail.surgePricing.minimumSurgeLevel = "double | 0.1"
beam.agentsim.agents.rideHail.surgePricing.priceAdjustmentStrategy = "KEEP_PRICE_LEVEL_FIXED_AT_ONE"
beam.agentsim.agents.rideHail.surgePricing.numberOfCategories = "int | 6"
# Scaling and Tuning Params
beam.agentsim.tuning.fuelCapacityInJoules = "double | 86400000"
beam.agentsim.tuning.transitCapacity = "Double?"
beam.agentsim.tuning.transitPrice = "double | 1.0"
beam.agentsim.tuning.tollPrice = "double | 1.0"
beam.agentsim.tuning.rideHailPrice = "double | 1.0"
# Population Adjustmnet
beam.agentsim.populationAdjustment = "DEFAULT_ADJUSTMENT"
# Transit Scenarios
beam.agentsim.scenarios.frequencyAdjustmentFile = ${beam.inputDirectory}"/r5/FrequencyAdjustment.csv"
# PhysSim Scaling Params
beam.physsim.flowCapacityFactor = "double | 1.0"
beam.physsim.storageCapacityFactor = "double | 1.0"
beam.physsim.linkStatsWriteInterval = "int | 1"
beam.physsim.linkStatsBinSize = "int | 3600"
beam.physsim.ptSampleSize = "double | 1.0"
beam.physsim.jdeqsim.agentSimPhysSimInterfaceDebugger.enabled = false
beam.physsim.jdeqsim.cacc.enabled = false
beam.physsim.jdeqsim.cacc.minRoadCapacity = "int | 2000"
beam.physsim.jdeqsim.cacc.minSpeedMetersPerSec = "int | 20"
beam.physsim.jdeqsim.cacc.speedAdjustmentFactor = "double | 1.0"
beam.physsim.jdeqsim.cacc.capacityPlansWriteInterval = 0
beam.physsim.jdeqsim.cacc.minimumRoadSpeedInMetersPerSecond = "double | 1.3"
beam.physsim.skipPhysSim = false
beam.physsim.eventsForFullVersionOfVia = true
beam.physsim.eventsSampling = "double | 1.0"
beam.physsim.initializeRouterWithFreeFlowTimes = true
beam.physsim.quick_fix_minCarSpeedInMetersPerSecond = "double | 0.5"
beam.physsim.inputNetworkFilePath = ${beam.inputDirectory}"/r5/physsim-network.xml"
beam.physsim.events.fileOutputFormats = "csv" # valid options: xml(.gz) , csv(.gz), none - DEFAULT: csv.gz
beam.physsim.events.eventsToWrite = "ActivityEndEvent,ActivityStartEvent,LinkEnterEvent,LinkLeaveEvent,PersonArrivalEvent,PersonDepartureEvent,VehicleEntersTrafficEvent,VehicleLeavesTrafficEvent"

beam.physsim.overwriteLinkParamPath = ""

# Replanning
beam.replanning.maxAgentPlanMemorySize = "int | 5"
beam.replanning.Module_1 = "SelectExpBeta"
beam.replanning.ModuleProbability_1 = 0.8
beam.replanning.Module_2 = "ClearRoutes"
beam.replanning.ModuleProbability_2 = 0.1
beam.replanning.Module_3 = "ClearModes"
beam.replanning.ModuleProbability_3 = 0.1
beam.replanning.Module_4 = "TimeMutator"
beam.replanning.ModuleProbability_4 = 0.0
beam.replanning.fractionOfIterationsToDisableInnovation = "double | Double.PositiveInfinity"
beam.replanning.cleanNonCarModesInIteration = "int | 0"

#h3
beam.h3.resolution = "int | 10"
beam.h3.lowerBoundResolution = "int | 10"

#skims
beam.router.skim = {
  keepKLatestSkims = "int | 1"
  writeSkimsInterval = "int | 0"
  writeAggregatedSkimsInterval = "int | 0"
  drive-time-skimmer {
    name = "drive-time-skimmer"
    fileBaseName = "String | skimsTravelTimeObservedVsSimulated"
  }
  origin-destination-skimmer {
    name = "od-skimmer"
    fileBaseName = "String | skimsOD"
    writeAllModeSkimsForPeakNonPeakPeriodsInterval = "int | 0"
    writeFullSkimsInterval = "int | 0"
  }
  taz-skimmer {
    name = "taz-skimmer"
    fileBaseName = "String | skimsTAZ"
  }
}

##################################################################
# Warm Mode
##################################################################
beam.warmStart.enabled = false
#PATH can be a directory or zip archive of the output directory (e.g. like what get's stored on S3), including a URL to an S3 output.
beam.warmStart.path = ""

beam.warmStart.skimsFileName = "skims.csv.gz"
beam.warmStart.skimsFilePath = "" # Filled by warmstart
beam.warmStart.skimsPlusFileName = "skimsPlus.csv.gz"
beam.warmStart.skimsPlusFilePath = "" # Filled by warmstart
beam.warmStart.routeHistoryFileName = "routeHistory.csv.gz"
beam.warmStart.routeHistoryFilePath = "" # Filled by warmstart

##################################################################
# Debugging
##################################################################
beam.debug.debugEnabled = false
beam.debug.agentTripScoresInterval = 0

beam.debug.triggerMeasurer {
  enabled = false
  writeStuckAgentDetectionConfig = true
}

beam.debug.stuckAgentDetection {
  enabled = false
  checkIntervalMs = "duration:ms | 200ms"
  defaultTimeoutMs = "duration:ms | 60s"
  overallSimulationTimeoutMs = "duration:ms | 100s"
  checkMaxNumberOfMessagesEnabled = true
  thresholds = [
    {
      triggerType = "beam.agentsim.agents.PersonAgent$ActivityStartTrigger"
      markAsStuckAfterMs = "duration:ms | 20s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.PersonAgent$ActivityEndTrigger"
      markAsStuckAfterMs = "duration:ms | 60s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.PersonAgent$PersonDepartureTrigger"
      markAsStuckAfterMs = "duration:ms | 20s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$StartLegTrigger"
      markAsStuckAfterMs = "duration:ms | 18s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$EndLegTrigger"
      markAsStuckAfterMs = "duration:ms | 60s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$AlightVehicleTrigger"
      markAsStuckAfterMs = "duration:ms | 21s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$BoardVehicleTrigger"
      markAsStuckAfterMs = "duration:ms | 21s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$StartRefuelSessionTrigger"
      markAsStuckAfterMs = "duration:ms | 21s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.modalbehaviors.DrivesVehicle$EndRefuelSessionTrigger"
      markAsStuckAfterMs = "duration:ms | 21s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.InitializeTrigger"
      markAsStuckAfterMs = "duration:ms | 20s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.ridehail.RideHailManager$BufferedRideHailRequestsTimeout"
      markAsStuckAfterMs = "duration:ms | 20s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
    {
      triggerType = "beam.agentsim.agents.ridehail.RideHailManager$RideHailAllocationManagerTimeout"
      markAsStuckAfterMs = "duration:ms | 40s"
      actorTypeToMaxNumberOfMessages {
        population = "int?"
        transitDriverAgent = "int?"
        rideHailAgent = "int?"
        rideHailManager = "int?"
      }
    },
  ]
}
beam.debug.debugActorTimerIntervalInSec = "int | 0"
beam.debug.actor.logDepth = "int | 0"
beam.debug.memoryConsumptionDisplayTimeoutInSec = "int | 0"
beam.debug.clearRoutedOutstandingWorkEnabled = false
beam.debug.secondsToWaitToClearRoutedOutstandingWork = 60

beam.logger.keepConsoleAppenderOn = "boolean | true"

##################################################################
# Metrics
##################################################################
beam.metrics.level = "verbose"

##################################################################
# Calibration
##################################################################
beam.calibration.objectiveFunction = "ModeChoiceObjectiveFunction"
beam.calibration.meanToCountsWeightRatio = "double | 0.5"
beam.calibration.mode.benchmarkFilePath = ""
beam.calibration.roadNetwork.travelTimes.zoneBoundariesFilePath = ""
beam.calibration.roadNetwork.travelTimes.zoneODTravelTimesFilePath = ""

##################################################################
# OUTPUTS
##################################################################
# The outputDirectory is the base directory where outputs will be written. The beam.agentsim.simulationName param will
# be used as the name of a sub-directory beneath the baseOutputDirectory for simulation results.
# If addTimestampToOutputDirectory == true, a timestamp will be added, e.g. "beamville_2017-12-18_16-48-57"
beam.outputs.baseOutputDirectory = "output"
beam.outputs.baseOutputDirectory = ${?BEAM_OUTPUT}
beam.outputs.addTimestampToOutputDirectory = true
beam.outputs.writeGraphs = true
beam.outputs.displayPerformanceTimings = false
beam.outputs.generalizedLinkStats.startTime = 25200
beam.outputs.generalizedLinkStats.endTime = 32400
# To keep all logging params in one place, BEAM overrides MATSim params normally in the controller config module
beam.outputs.defaultWriteInterval = 1
beam.outputs.writePlansInterval = "int | 0"
beam.outputs.writeEventsInterval = "int | 1"
beam.outputs.writeAnalysis = "boolean | true"
beam.outputs.writeLinkTraversalInterval = "int | 0"
beam.physsim.writeEventsInterval = "int | 0"
beam.physsim.writePlansInterval = "int | 0"
beam.physsim.writeRouteHistoryInterval = "int | 10"
beam.physsim.linkStatsWriteInterval = "int | 0"
beam.physsim.writeMATSimNetwork = "boolean | true"
beam.outputs.generalizedLinkStatsInterval = 0

# The remaining params customize how events are written to output files
beam.outputs.events.fileOutputFormats = "csv" # valid options: xml(.gz) , csv(.gz), none - DEFAULT: csv.gz

# Events Writing Logging Levels:
# Any event types not explicitly listed in overrideWritingLevels take on defaultWritingLevel
beam.outputs.events.eventsToWrite = "ActivityEndEvent,ActivityStartEvent,PersonEntersVehicleEvent,PersonLeavesVehicleEvent,ModeChoiceEvent,PathTraversalEvent,ReserveRideHailEvent,ReplanningEvent,RefuelSessionEvent,ChargingPlugInEvent,ChargingPlugOutEvent,ParkingEvent,LeavingParkingEvent"
beam.outputs.stats.binSize = 3600

##################################################################
# SPATIAL
##################################################################
beam.spatial = {
  localCRS = "epsg:32631"  # what crs to use for distance calculations, must be in units of meters
  boundingBoxBuffer = 5000 # meters of buffer around network for defining extend of spatial indices
}

##################################################################
# MATSim Conversion
##################################################################
matsim.conversion {
  scenarioDirectory = "/path/to/scenario/directory"
  populationFile = "Siouxfalls_population.xml"
  matsimNetworkFile = "Siouxfalls_network_PT.xml"
  generateVehicles = true
  vehiclesFile = "Siouxfalls_vehicles.xml"
  defaultHouseholdIncome {
    currency = "usd"
    period = "year"
    value = 50000
  }
  osmFile = "south-dakota-latest.osm.pbf"
  shapeConfig {
    shapeFile = "tz46_d00.shp"
    tazIdFieldName = "TZ46_D00_I"
  }
}

##################################################################
# BEAM ROUTING
##################################################################
beam.routing {
  #Base local date in ISO 8061 YYYY-MM-DDTHH:MM:SS+HH:MM
  baseDate = "2016-10-17T00:00:00-07:00"
  transitOnStreetNetwork = true # PathTraversalEvents for transit vehicles
  r5 {
    directory = ${beam.inputDirectory}"/r5"
    # Departure window in min
    departureWindow = "double | 15.0"
    numberOfSamples = "int | 1"
    osmFile = ${beam.inputDirectory}"/r5/beamville.osm.pbf"
    osmMapdbFile = ${beam.inputDirectory}"/r5/osm.mapdb"
    mNetBuilder.fromCRS = "EPSG:4326" # WGS84
    mNetBuilder.toCRS = "EPSG:26910"     # UTM10N
  }
  startingIterationForTravelTimesMSA = "int | 0"
}

##################################################################
# Counts
##################################################################
beam.calibration.counts {
  countsScaleFactor = 10
  writeCountsInterval = 1
  averageCountsOverIterations = 1
  inputCountsFile = ${beam.inputDirectory}"/counts.xml"
}

##################################################################
# MATSim Modules
##################################################################

matsim.modules {
  global {
    randomSeed = 4711
    coordinateSystem = "Atlantis"
  }
  counts {
    countsScaleFactor = 10.355
    averageCountsOverIterations = 0
    writeCountsInterval = 0
    inputCountsFile = ""
    outputformat = "all"
  }
  network {
    inputNetworkFile = ${beam.inputDirectory}"/physsim-network.xml"
  }
  plans {
    inputPlansFile = ${beam.inputDirectory}"/population.xml"
    inputPersonAttributesFile = ${beam.inputDirectory}"/populationAttributes.xml"
  }
  households {
    inputFile = ${beam.inputDirectory}"/households.xml"
    inputHouseholdAttributesFile = ${beam.inputDirectory}"/householdAttributes.xml"
  }
  vehicles {
    vehiclesFile = ""
  }
  strategy {
    maxAgentPlanMemorySize = 5
    planSelectorForRemoval = "WorstPlanForRemovalSelector"

    ModuleProbability_1 = 0.0
    Module_1 = ""

    ModuleProbability_2 = 0.0
    Module_2 = ""

    ModuleProbability_3 = 0.0
    Module_3 = ""

    ModuleProbability_4 = 0.0
    Module_4 = ""

    fractionOfIterationsToDisableInnovation = 999999

    parameterset = [
      {
        type = "strategysettings"
        disableAfterIteration = -1
        strategyName = ""
        weight = 0.0
      },
      {
        type = "strategysettings"
        disableAfterIteration = -1
        strategyName = ""
        weight = 0.0
      },
      {
        type = "strategysettings"
        disableAfterIteration = -1
        strategyName = ""
        weight = 0.0
      },
      {
        type = "strategysettings"
        disableAfterIteration = -1
        strategyName = ""
        weight = 0.0
      }
    ]
  }
  parallelEventHandling {
    #Estimated number of events during mobsim run. An optional optimization hint for the framework.
    estimatedNumberOfEvents = 1000000000
    #Number of threads for parallel events handler. 0 or null means the framework decides by itself.
    numberOfThreads = 1
    #If enabled, each event handler is assigned to its own thread. Note that enabling this feature disabled the numberOfThreads option! This feature is still experimental!
    oneThreadPerHandler = false
    # If enabled, it is ensured that all events that are created during a time step of the mobility simulation are processed before the next time step is simulated. E.g. neccessary when within-day replanning is used.
    synchronizeOnSimSteps = false
  }
  controler {
    outputDirectory = ""
    firstIteration = 0
    lastIteration = 0
    eventsFileFormat = "xml"
    mobsim = "metasim"
    overwriteFiles = "overwriteExistingFiles"
  }
  qsim {
    #"start/endTime" of MobSim (00:00:00 == take earliest activity time/ run as long as active vehicles exist) -->
    startTime = "00:00:00"
    endTime = "30:00:00"
    #00:00:00 means NO snapshot writing
    snapshotperiod = "00:00:00"
  }
  transit {
    useTransit = false
    vehiclesFile = ""
    transitModes = "pt"
  }
  changeMode {
    modes = "car,pt"
  }
  planCalcScore {
    writeExperiencedPlans = true
    learningRate = "1.0"
    BrainExpBeta = "2.0"
    lateArrival = "-18"
    earlyDeparture = "-0"
    performing = "6.0"
    traveling = "-6.0"
    waiting = "-0"

    parameterset = [
      {
        type = "activityParams"
        activityType = "Home"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "01:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Work"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "9:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Shopping"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "9:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Social"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "4:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Eatout"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "2:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "School"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "8:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Escort"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "00:30:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "University"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "08:00:00"
        typicalDurationScoreComputation = "uniform"
      }, {
        type = "activityParams"
        activityType = "Other"
        priority = 1.0
        scoringThisActivityAtAll = true
        typicalDuration = "02:00:00"
        typicalDurationScoreComputation = "uniform"
      }
    ]
  }
  linkStats {
    writeLinkStatsInterval = "int | 10"
    averageLinkStatsOverIterations = "int | 5"
  }
}

